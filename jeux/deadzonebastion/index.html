<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dead Zone Bastion</title>
    <style>
        /* STYLE.CSS */
        
        :root {
            --bg-color: #1a1a1a;
            --text-color: #ecf0f1;
            --accent-gold: #f1c40f;
            --accent-diamond: #3498db;
            --danger: #e74c3c;
            --success: #2ecc71;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            cursor: url('./images/pointeur.PNG'), auto;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 720px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: url('./images/fondaccueil.jpg') no-repeat center center;
            background-size: cover;
            cursor: url('./images/pointeur.PNG'), auto;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: url('./images/pointeur.PNG'), auto;
        }

        /* Image Titre */
        #menu-title-img {
            width: 100%;
            max-width: 400px; /* Ajuste selon la taille souhait√©e */
            height: auto;
            margin-bottom: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        /* Diamants en haut √† gauche */
        #menu-diamonds-box {
            margin-top: 0px;
            background: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #444;
            color: var(--accent-diamond);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
        }

                /* Conteneur des boutons */
        .menu-buttons-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 100%;
        }

        /* Bouton Jouer Carr√© et Grand */
        .btn-play-big {
            width: 150px;
            height: 150px;
            font-size: 1.8rem;
            border-radius: 15px;
            position: relative;
            z-index: 10; /* Au-dessus des zombies */
            border: 3px solid var(--accent-gold);
        }

        /* Boutons secondaires align√©s */
        .secondary-buttons {
            display: flex;
            gap: 20px;
        }

        /* --- EFFET ZOMBIE --- */

        /* Styles communs √† tous les zombies */
        .menu-zombie {
            position: absolute;
            opacity: 0; /* Invisible par d√©faut */
            width: 80px;
            height: auto;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            pointer-events: none;
            z-index: 5; /* En dessous du bouton (z-index 10) */
        }

        /* --- ZOMBIE DE DROITE --- */
        .z-right {
            top: 45%;
            left: 50%;
            /* Position initiale : Cach√© DERRI√àRE le bord droit du bouton */
            /* Le bouton fait 150px de large (75px de chaque c√¥t√© du centre).
            On place le centre du zombie √† +75px, donc il est cach√© par le bouton. */
            transform: translateX(10px) translateY(-50%);
        }

        /* --- ZOMBIE DE GAUCHE --- */
        .z-left {
            top: 45%;
            left: 50%;
            /* Position initiale : Cach√© DERRI√àRE le bord gauche du bouton */
            transform: translateX(-75px) translateY(-50%);
        }

        /* --- ZOMBIE DU HAUT --- */
        .z-top {
            top: 45%;
            left: 50%;
            /* Position initiale : Cach√© DERRI√àRE le bord haut du bouton */
            transform: translateX(-50%) translateY(-75px);
        }

        /* --- ANIMATION AU SURVOL --- */

        /* Faire appara√Ætre les zombies (opacit√© 1) */
        .play-btn-wrapper:hover .menu-zombie {
            opacity: 1;
        }

        /* Mouvement du zombie de droite */
        .play-btn-wrapper:hover .z-right {
            /* Il sort de 30px vers la droite (75 + 30) */
            transform: translateX(85px) translateY(-50%); 
        }

        /* Mouvement du zombie de gauche */
        .play-btn-wrapper:hover .z-left {
            /* Il sort de 30px vers la gauche (-75 - 30) */
            transform: translateX(-160px) translateY(-50%);
        }

        /* Mouvement du zombie du haut */
        .play-btn-wrapper:hover .z-top {
            /* Il sort de 30px vers le haut (-75 - 30) */
            transform: translateX(-50%) translateY(-125px);
        }

        /* --- UI HUD --- */
        #hud-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 5;
        }

        .hud-info-group {
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .hud-stat {
            display: flex;
            flex-direction: row;
            align-items: center;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid #444;
            gap: 10px;
        }

        .hud-icon {
            width: 28px;
            height: 28px;
            object-fit: contain;
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
        }

        .hud-text-wrapper {
            display: flex;
            flex-direction: column;
            line-height: 1;
            justify-content: center;
        }

        .hud-stat-label { font-size: 0.65rem; color: #aaa; text-transform: uppercase; }
        .hud-stat-value { font-size: 1.2rem; font-weight: bold; line-height: 1.2; }
        .color-gold { color: var(--accent-gold); }
        .color-diamond { color: var(--accent-diamond); }

        #hud-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 300px;
        }

        .wave-progress-container {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        .wave-progress-bar {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 0.2s;
        }

        #btn-settings {
            position: absolute;
            top: 10px;
            right: 20px;
            z-index: 20;
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            pointer-events: auto;
        }
        #btn-settings:hover { opacity: 1; }

        /* --- Overlays --- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .hidden { display: none !important; }

        h1 { font-size: 3rem; color: var(--danger); text-transform: uppercase; margin-bottom: 2rem; text-shadow: 2px 2px 0px #000; }
        h2 { color: var(--accent-gold); margin-bottom: 20px; }

        .settings-content {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            /* MODIFICATION DEMAND√âE : Fond noir sans transparence pour le conteneur global des param√®tres */
            background: #000; 
        }

        .btn {
            background: linear-gradient(to bottom, #4a4a4a, #2c2c2c);
            border: 2px solid #666;
            color: white;
            padding: 15px 40px;
            font-size: 1.2rem;
            margin: 10px;
            cursor: url('./images/pointeur.png'), auto;
            border-radius: 5px;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: bold;
            pointer-events: auto;
            /* MODIFICATION : Pour que le texte ne d√©passe pas */
            white-space: nowrap; 
        }
        .btn:hover {
            transform: scale(1.05);
            border-color: var(--accent-gold);
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5);
        }
        .btn-danger { border-color: var(--danger); }
        .btn-danger:hover { border-color: red; box-shadow: 0 0 15px rgba(231, 76, 60, 0.5); }
        .btn-small { padding: 10px 20px; font-size: 1rem; }

        /* Panneaux (Menu, Labo, Settings) */
        .menu-panel, .lab-panel {
            background: rgba(30, 30, 30, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #555;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            position: relative;
        }
        
        /* MODIFICATION CSS : Style sp√©cifique pour le panneau settings */
        .settings-panel { 
            width: 450px; /* Un peu plus large pour accommoder les textes longs */
            background: #111; /* Fond noir opaque demand√© */
            padding: 40px;
            border: 1px solid #444;
            border-radius: 10px;
            text-align: center;
        }

        .menu-panel { width: 500px; }
        .lab-panel { width: 900px; max-width: 95%; }
        
        .setting-row { margin: 15px 0; display: flex; justify-content: space-between; align-items: center; }
        input[type=range] { width: 60%; }

        /* MODIFICATION CSS : Conteneur des boutons settings pour alignement et taille */
        .settings-buttons-container {
            margin-top: 30px; 
            border-top: 1px solid #333; 
            padding-top: 20px; 
            display: flex; 
            flex-direction: column; 
            gap: 15px;
            align-items: stretch; /* Force les boutons √† prendre toute la largeur */
        }
        
        .settings-buttons-container .btn {
            margin: 0; /* Reset des marges pour le flex gap */
            width: 100%; /* S'assure que le bouton remplit le conteneur flex */
        }

        /* Tabs Labo */
        .lab-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .lab-tab {
            background: #333;
            border: 1px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.2s;
        }
        .lab-tab.active { background: #555; border-color: var(--accent-gold); color: white; }
        
        .lab-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .lab-card {
            background: #222;
            border: 1px solid #444;
            padding: 15px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .lab-card h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent-gold); }
        .lab-card p { margin: 5px 0; font-size: 0.9rem; color: #ccc; }

        /* Cr√©dits */
        .credits-content {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            color: #aaa;
            font-size: 0.9rem;
            text-align: left;
        }

        /* Style pour l'inspecteur d'ennemi */
        #enemy-inspector {
            position: absolute;
            top: 60px; /* Positionn√© sous le bouton settings qui est en haut */
            right: 20px; /* √Ä droite de l'√©cran */
            z-index: 15; /* Au-dessus du canvas mais sous les menus principaux */
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #e74c3c; /* Bordure rouge */
            border-radius: 5px;
            padding: 10px;
            color: #ccc;
            font-size: 0.9rem;
            min-width: 140px;
            pointer-events: none; /* Pour que les clics traversent le panneau */
        }

            /* --- GESTION DE LA VITESSE (Nouveau syst√®me) --- */
    .speed-btn-group {
        display: flex;
        flex-direction: column; /* Affichage vertical des boutons */
        gap: 5px; /* Petit espace entre chaque bouton */
        position: absolute;
        /* Position : Sur le bord gauche du canvas (au centre verticalement) */
        left: 10px; 
        top: 50%; 
        transform: translateY(-50%); /* Pour centrer verticalement */
        z-index: 6; /* Au-dessus du canvas mais sous les autres UI (HUD) */
        pointer-events: auto;
    }

    .speed-btn {
        width: 35px; /* Plus petit que le bouton pr√©c√©dent (50x) */
        height: 30px;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.5); /* Fond l√©g√®rement transparent */
        border: 1px solid #444;
        color: white;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s, border-color 0.2s;
        pointer-events: auto;
    }

    /* Classe pour le bouton s√©lectionn√© */
    .speed-btn.active {
        background: #27ae60; /* Bleu (Diamond color) pour le bouton actif */
        border-color: '#3498db';
        font-size: 1.2rem; /* Texte un peu plus grand quand actif */
    }

    /* Classe pour les boutons inactifs */
    .speed-btn.inactive {
        background: 'rgba(0,0,0,0.3)';
        border-color: '#444';
        font-size: 1rem;
    }

    /* Force le curseur personnalis√© sur tous les √©l√©ments interactifs */
    button, a, .btn, .lab-tab, input[type=range] {
        cursor: url('./images/pointeur.png'), auto !important;
    }

        /* Style du logo ToncPlay */
        #toncplay-logo {
            position: absolute; /* Positionnement par rapport √† la page */
            top: 10px;          /* Distance du haut de la page */
            left: 10px;         /* Distance du c√¥t√© gauche */
            z-index: 1000;      /* Place le logo au-dessus des autres √©l√©ments */
            display: block;     /* Assure que le lien reste un bloc cliquable */
            overflow: visible;
        }

        #toncplay-logo img {
            width: 60px;       /* Ajustez la taille du logo */
            height: auto;       /* Maintient les proportions */
            cursor: pointer;    /* Change le curseur pour indiquer un lien */
        }

        /* Position et style du tooltip */
        #toncplay-logo[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 110%; 
            left: 50%;
            transform: translateX(-50%);
            
            /* --- NOUVEAU STYLE --- */
            background-color: rgba(20, 20, 20, 0.98); /* Fond noir tr√®s sombre */
            color: var(--accent-gold); /* Texte Dor√© (comme les pi√®ces) */
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--accent-gold); /* Bordure fine dor√©e */
            
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            white-space: nowrap;
            
            /* Effet de texte */
            text-shadow: 1px 1px 0px #000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* Petite animation d'apparition */
        #toncplay-logo[data-tooltip]:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px); /* Monte l√©g√®rement */
        }

        /* Style de base pour le tooltip */
        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8); /* Fond noir avec opacit√© */
            color: #fff; /* Texte blanc */
            padding: 5px 10px; /* Espacement interne */
            border-radius: 5px; /* Coins arrondis */
            font-size: 12px; /* Taille de la police */
            pointer-events: none; /* Emp√™che d'interagir avec le tooltip */
            z-index: 1000; /* Affiche par-dessus les autres √©l√©ments */
            white-space: nowrap; /* Emp√™che le texte de se couper */
        }

        #footerText {
            position: absolute;
            bottom: 0;
            width: fit-content;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px 20px; 
            background: rgba(26, 26, 26, 0.95);
            color: #ecf0f1;
            border: 2px solid var(--accent-gold); 
            border-radius: 15px;             
            box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
        }

        #footerText a {
            color: var(--accent-gold);
            text-decoration: none;
            margin-left: 5px;
            font-weight: bold;
            transition: color 0.2s;
        }

        #footerText a:hover {
            color: #fff;
            text-shadow: 0 0 5px var(--accent-gold);
        }
    </style>
</head>
<body>

<a href="../../index.html" id="toncplay-logo" data-tooltip="Retourner √† la page d'accueil ToncPlay">
    <img src="../../images/logo.png" alt="ToncPlay Logo">
</a>   

<div id="game-container">
    <div id="enemy-inspector" class="hidden">
        <div style="font-weight:bold; color:#e74c3c; border-bottom:1px solid #555; margin-bottom:5px;">
            <span id="insp-name">Ennemi</span>
        </div>
        <div style="display:flex; justify-content:space-between; gap:10px;">
            <span>PV:</span> <span id="insp-hp" style="color:#fff">0</span>
        </div>
        <div style="display:flex; justify-content:space-between; gap:10px;">
            <span>D√©g√¢ts:</span> <span id="insp-dmg">0</span>
        </div>
        <div style="display:flex; justify-content:space-between; gap:10px;">
            <span>Type:</span> <span id="insp-type">-</span>
        </div>
    </div>
    <div id="hud-bar" class="hidden">
        <div class="hud-info-group">
            <div class="hud-stat">
                <img src="./images/piece.png" class="hud-icon" alt="Coins">
                <div class="hud-text-wrapper">
                    <span class="hud-stat-label color-gold">PI√àCES</span>
                    <span class="hud-stat-value" id="hud-coins">0</span>
                </div>
            </div>

            <div class="hud-stat">
                <img src="./images/diamant.png" class="hud-icon" alt="Diamonds">
                <div class="hud-text-wrapper">
                    <span class="hud-stat-label color-diamond">DIAMANTS</span>
                    <span class="hud-stat-value" id="hud-diamonds">0</span>
                </div>
            </div>
        </div>

        <div id="hud-center">
            <div style="font-weight:bold;">JOUR <span id="hud-day">1</span> - VAGUE <span id="hud-wave">1</span></div>
            <div class="wave-progress-container">
                <div id="wave-progress" class="wave-progress-bar"></div>
            </div>
        </div>
        
        <div style="width: 200px; position: relative; display: flex; justify-content: flex-end;">
             <button id="btn-settings" class="hidden" style="position: static; margin:0;">‚öôÔ∏è</button>
        </div>
    </div>
    <div class="speed-btn-group hidden">
        <button id="btn-speed-1" class="speed-btn" onclick="setSpeed(1)">x1</button>
        <button id="btn-speed-2" class="speed-btn" onclick="setSpeed(2)">x2</button>
        <button id="btn-speed-3" class="speed-btn" onclick="setSpeed(3)">x3</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="menu-overlay" class="overlay">
        <div class="menu-panel">
            <!-- 1. Image Titre -->
            <img src="./images/titre.png" id="menu-title-img" alt="Titre">
            <!-- 2. Conteneur des boutons -->
            <div class="menu-buttons-wrapper">
                
                <!-- Bouton Jouer + Zombies -->
                <div class="play-btn-wrapper">
                    <img src="./images/imgzombie7.png" class="menu-zombie z-top">
                    <img src="./images/imgzombie4.png" class="menu-zombie z-left">
                    <img src="./images/imgzombie3.png" class="menu-zombie z-right">
                    <button class="btn btn-play-big" id="btn-play">JOUER</button>
                </div>

                <!-- 3. DIAMANTS  -->
                <div id="menu-diamonds-box">
                    <span id="menu-diamonds">0</span>
                    <img src="./images/diamant.png" style="width:24px; vertical-align:middle;">
                </div>

                <!-- Boutons Secondaires -->
                <div class="secondary-buttons">
                    <button class="btn" id="btn-lab">Laboratoire</button>
                    <button class="btn" id="btn-menu-settings">Param√®tres</button>
                </div>

                <!-- bouton Statistiques -->
                <button class="btn" id="btn-stats" style="padding: 10px 30px; font-size: 1rem;">Statistiques</button>

            </div>
        </div>
    </div>

    <div id="gameover-overlay" class="overlay hidden">
        <div class="menu-panel">
            <h1 style="color: red; font-size: 2.5rem;">Partie Termin√©e</h1>
            <h2 id="gameover-reason">Le Bastion est d√©truit !</h2>
            <div style="margin-top: 20px; text-align: center; font-size: 1.2rem;">
                <p>Surv√©cu jusqu'au Jour <span id="go-day">1</span></p>
                <p>Vague atteinte : <span id="go-wave">1</span></p>
                <p>Diamants gagn√©s (Run) : <span id="go-diamonds" style="color:var(--accent-diamond)">0</span></p>
            </div>
            <br>
            <button class="btn" id="btn-menu">Retour Menu</button>
        </div>
    </div>

    <div id="lab-overlay" class="overlay hidden">
        <div class="lab-panel">
            <h1 style="font-size:2rem; margin-top:0;">Laboratoire</h1>
            <div style="color: var(--accent-diamond); margin-bottom: 10px;">R√©serve : <span id="lab-diamonds">0</span> <img src="./images/diamant.png" style="width:24px; vertical-align:middle;"></div>
            
            <div class="lab-tabs">
                <div class="lab-tab active" data-tab="Bastion">Bastion</div>
                <div class="lab-tab" data-tab="PV">Point de vie</div>
                <div class="lab-tab" data-tab="√âconomie">Economie</div>
                <div class="lab-tab" data-tab="Sorts">Sorts</div>
            </div>

            <div id="lab-content" class="lab-grid">
                </div>
            
            <button class="btn" id="btn-close-lab" style="margin-top: 20px; padding: 10px 30px; font-size: 1rem;">Fermer</button>
        </div>
    </div>

    <div id="settings-overlay" class="overlay hidden">
        <div class="settings-content">
            <div class="settings-panel">
                <h2>Param√®tres</h2>
                
                <div class="setting-row">
                    <label>Musique</label>
                    <input type="range" id="vol-music" min="0" max="100" value="50">
                </div>
                <div class="setting-row">
                    <label>Effets Sonores</label>
                    <input type="range" id="vol-sfx" min="0" max="100" value="80">
                </div>
                
                <div style="display:flex; justify-content:center; margin-top:20px;">
                    <button class="btn btn-small" id="btn-toggle-credits" style="background:#555;">Afficher Cr√©dits</button>
                </div>

                <div id="credits-section" class="credits-content hidden">
                    <h3 style="margin-top:0; color:var(--accent-gold); border-bottom:1px solid #555; padding-bottom:10px;">Cr√©dits</h3>
                    <p><strong>D√©veloppement :</strong> Sluto</p>
                    <p><strong>Graphismes :</strong> Sluto</p>
                    <p><strong>Musique et Son :</strong> Suno et pixabay</p>
                </div>

                <div class="settings-buttons-container">
                    <button class="btn" id="btn-resume" class="hidden">Reprendre</button>
                    <button class="btn" id="btn-quit">Quitter vers le Menu</button>
                    <button class="btn btn-danger" id="btn-reset-save" style="font-size: 1rem;">R√©initialiser la Partie</button>
                    <button class="btn" id="btn-close-settings-menu" class="hidden">Fermer</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Page Statistiques -->
    <div id="stats-overlay" class="overlay hidden">
        <div class="menu-panel" style="width: 800px; max-height: 90vh; overflow-y: auto;">
            <h1 style="font-size: 2.5rem; color: #3498db;">Statistiques</h1>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; text-align: left;">
                
                <!-- Carte : Meilleure Run -->
                <div class="lab-card" style="background: #2c3e50; border: 1px solid var(--accent-gold);">
                    <h3 style="color: var(--accent-gold); text-align: center;">üèÜ Meilleure Run</h3>
                    <div style="margin-top: 15px;">
                        <p><strong>Date :</strong> <span id="stat-best-date">-</span></p>
                        <p><strong>Jour :</strong> <span id="stat-best-day">0</span></p>
                        <p><strong>Vague :</strong> <span id="stat-best-wave">0</span></p>
                        <p><strong>Diamants :</strong> <span id="stat-best-diamonds" style="color: var(--accent-diamond)">0</span> üíé</p>
                    </div>
                </div>

                <!-- Carte : G√©n√©ral -->
                <div class="lab-card" style="background: #2c3e50;">
                    <h3 style="color: #fff; text-align: center;">üìä G√©n√©ral</h3>
                    <div style="margin-top: 15px;">
                        <p><strong>Run effectu√©es :</strong> <span id="stat-total-runs">0</span></p>
                        <p><strong>Diamants Totaux Gagn√©s :</strong> <span id="stat-total-diamonds" style="color: var(--accent-diamond)">0</span> üíé</p>
                        <p><strong>Temps de jeu :</strong> <span id="stat-playtime">0 min</span></p>
                    </div>
                </div>

                <!-- Carte : Combat (Prend toute la largeur) -->
                <div class="lab-card" style="background: #2c3e50; grid-column: span 2;">
                    <h3 style="color: #e74c3c; text-align: center;">‚öîÔ∏è Combat</h3>
                    <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                        <div style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #e74c3c;" id="stat-total-kills">0</div>
                            <div>Zombies Tu√©s</div>
                        </div>
                        <div style="width: 1px; background: #555;"></div>
                        <div style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #c0392b;" id="stat-total-bosses">0</div>
                            <div>Boss Tu√©s</div>
                        </div>
                    </div>
                </div>

            </div>

            <button class="btn" id="btn-close-stats" style="margin-top: 30px; padding: 10px 40px;">Fermer</button>
        </div>
    </div>
</div>

<script>
/**
 * SCRIPT.JS
 */

/* =========================================================
   1. CONFIGURATION & CONSTANTES
   ========================================================= */
const speedBtnGroup = document.querySelector('.speed-btn-group');
const INVERTED_SPRITES = ['zombie2', 'zombie3', 'boss1'];

const ZOMBIE_METADATA = { 
    'zombie1': { frames: 7, animDelay: 10 }, 
    'zombie2': { frames: 8, animDelay: 10 },  
    'zombie3': { frames: 8, animDelay: 10 }, 
    'zombie4': { frames: 8, animDelay: 10 }, 
    'zombie5': { frames: 8, animDelay: 10 }, 
    'zombie6': { frames: 4, animDelay: 20 }, 
    'zombie7': { frames: 18, animDelay: 8 }, 
    'zombie8': { frames: 4, animDelay: 20 }, 
    'boss1': { frames: 15, animDelay: 10 },
    'boss2': { frames: 12, animDelay: 12 },
    'boss3': { frames: 14, animDelay: 10 },
    'boss4': { frames: 13, animDelay: 11 }
};

/* =========================================================
   LISTE DES NOMS ET TYPES
   ========================================================= */

const ZOMBIE_NAMES = {
    'zombie1': "G√©g√© la veste",
    'zombie2': "La veuve Brise-Crane",
    'zombie3': "Bob le chantier",
    'zombie4': "Blanche-Nuit",
    'zombie5': "Patient Zero",
    'zombie6': "L'Officier Morsure",
    'zombie7': "Boomer",
    'zombie8': "Jean L'√©clair",
    'boss1': "Sylas le Sanglant",
    'boss2': "L'≈íil du Chaos",
    'boss3': "Hexa-Mort",
    'boss4': "Le g√©n√©ral de la Horde"
};

function getZombieTypeName(variant) {
    switch(variant) {
        case 'sprinter': return 'Rapide';
        case 'tank': return 'Tank';
        case 'kamikaze': return 'Kamikaze';
        case 'boss': return 'Boss';
        default: return 'Normal';
    }
}

const CONFIG = {
    coinDropMin: 5,
    coinDropMax: 15,
    bossDiamondDropBase: 50, 
    mineBaseInterval: 10000,
    spawnInterval: 600,
    difficultyMultiplierDay: 0.25, // augmenter difficulter
    
    // Animation Sprite Sheet
    spriteAnimSpeed: 40,
    
    // Sizing
    towerDisplayWidth: 180,
    mineSize: 100,
    zombieSize: 40,
    bossSize: 120,
    
    // Projectile settings
    arrowDisplayWidth: 8, 
    bloodScale: 2,         
    
    // Enemy Types (Mapping indices)
    enemies: {
        normal: [0, 1, 4, 5], 
        sprinter: [3, 7], 
        tank: 2, 
        kamikaze: 6 
    },
    
    // Configuration des Sorts
    spells: {
        prison: {
            id: 'prison',
            name: 'Prison (1)',
            cost: 10,
            cooldown: 30000,
            duration: 5000,
            icon: './images/prison.jpg',
            desc: "Immobilise un ennemi.",
            color: '#e74c3c'
        },
        rain: {
            id: 'rain',
            name: 'Pluie de Fl√®ches (2)',
            cost: 20,
            cooldown: 20000,
            damage: 200,
            radius: 90,
            arrowCount: 15,
            icon: './images/pluiefleche.jpg',
            desc: "Zone de d√©g√¢ts.",
            color: '#f39c12'
        },
        circle: {
            id: 'circle',
            name: 'Cercle de Fl√®ches (3)',
            baseCost: 20, // Co√ªt de base
            cooldown: 10000,
            icon: './images/cerclefleche.png',
            desc: "Tire en cercle autour du bastion.",
            color: '#9b59b6' // Couleur violette
        },
    },
    
    images: {
        bg: './images/fond.png',
        bg_menu: './images/fondaccueil.jpg',
        tower: './images/bastion.png', 
        mine: './images/minediamant.png',
        coin: './images/piece.png',
        diamond: './images/diamant.png',
        zombies: Array.from({length: 8}, (_, i) => `./images/zombie${i+1}.png`),
        bosses: Array.from({length: 4}, (_, i) => `./images/boss${i+1}.png`),
        arrow: './images/fleche.png',
        blood: './images/sang.png',
        barreau: './images/barreau.png',
        prison_icon: './images/prison.jpg',
        rain_icon: './images/pluiefleche.jpg',
        cercle_icon: './images/cerclefleche.png'
    }
};

// Formules Tour/Jeu
const FORMULAS = {
    getRange: (lvl) => 200 + ((lvl - 1) * ((500 - 200) / 24)),
    getAttackDelay: (lvl) => Math.max(150, 1000 + ((lvl - 1) * ((500 - 1000) / 24))),
    getMineProduction: (lvl) => Math.floor(1 + ((lvl - 1) * ((26 - 1) / 24))),
    getWaveBonus: (lvl) => Math.floor(((lvl - 1) / 24) * 300),
    getDamage: (lvl) => 10 + ((lvl - 1) * ((100 - 10) / 24)),
    getCritChance: (lvl) => 5 + ((lvl - 1) * ((50 - 5) / 24)),
    getMultiShotChance: (lvl) => ((lvl - 1) / 24) * 25,
    getMaxHp: (lvl) => 100 + ((lvl - 1) * ((1000 - 100) / 24)),
    getRegen: (lvl) => (lvl - 1) * 1,
    getLifesteal: (lvl) => ((lvl - 1) / 24) * 20,
    getBossDiamondBonus: (lvl) => (lvl - 1) * 2,
    getKillBonus: (lvl) => lvl,
};

const SPELL_FORMULAS = {
    getPrisonCost: (lvl) => Math.max(1, 10 - (lvl - 1)),
    getPrisonDuration: (lvl) => 5000 + ((lvl - 1) * ((15000 - 5000) / 9)),
    getRainCost: (lvl) => Math.max(10, 20 - (lvl - 1)),
    getRainDamage: (lvl) => 200 + ((lvl - 1) * ((400 - 200) / 9)),
    getCircleCost: (lvl) => Math.max(10, 20 - (lvl - 1)), // Baisse de 1 par niveau, min 10
    getCircleCount: (lvl) => 10 + ((lvl - 1) * 2) // +2 fl√®ches par niveau, commence √† 10
};

const UPGRADES_DATA = [
    { id: 'damage', name: "D√©g√¢ts", tab: "Bastion", basePrice: 50, labBasePrice:5, ratio: 1.5, maxLevel: 25, description: "Puissance de tir.", formula: FORMULAS.getDamage },
    { id: 'speed', name: "Vitesse Tir", tab: "Bastion", basePrice: 80, labBasePrice: 8, ratio: 1.6, maxLevel: 25, description: "D√©lai de recharge.", formula: FORMULAS.getAttackDelay },
    { id: 'crit', name: "Coup Critique", tab: "Bastion", basePrice: 120, labBasePrice: 12, ratio: 1.7, maxLevel: 25, description: "Chance de d√©g√¢ts x2.", formula: FORMULAS.getCritChance },
    { id: 'multishot', name: "Tir Multiple", tab: "Bastion", basePrice: 80, labBasePrice: 8, ratio: 1.6, maxLevel: 25, description: "Chance de tirer 2 fl√®ches.", formula: FORMULAS.getMultiShotChance },
    { id: 'range', name: "Port√©e Tour", tab: "Bastion", basePrice: 40, labBasePrice: 4, ratio: 1.3, maxLevel: 25, description: "Distance de tir.", formula: FORMULAS.getRange },
    { id: 'hp', name: "PV Max", tab: "PV", basePrice: 30, labBasePrice: 3, ratio: 1.4, maxLevel: 25, description: "Point de vie du Bastion.", formula: FORMULAS.getMaxHp },
    { id: 'regen', name: "R√©g√©n√©ration", tab: "PV", basePrice: 150, labBasePrice: 15, ratio: 1.6, maxLevel: 25, description: "Soigne automatiquement.", formula: FORMULAS.getRegen },
    { id: 'lifesteal', name: "Vol de vie", tab: "PV", basePrice: 200, labBasePrice: 20, ratio: 1.8, maxLevel: 25, description: "Vole des PV aux ennemis.", formula: FORMULAS.getLifesteal },
    { id: 'wave_bonus', name: "Argent Vague", tab: "√âconomie", basePrice: 60, labBasePrice: 6, ratio: 1.4, maxLevel: 25, description: "Gain de pi√®ces par vague.", formula: FORMULAS.getWaveBonus },
    { id: 'mine_rate', name: "Production Mine", tab: "√âconomie", basePrice: 100, labBasePrice: 10, ratio: 1.5, maxLevel: 25, description: "Diamants toute les 10s", formula: FORMULAS.getMineProduction },
    { id: 'boss_diamond', name: "Diamant Boss", tab: "√âconomie", basePrice: 20, labBasePrice: 2, ratio: 1.5, maxLevel: 25, description: "Diamants en plus par Boss.", formula: FORMULAS.getBossDiamondBonus },
    { id: 'kill_bonus', name: "Argent par kill", tab: "√âconomie", basePrice: 20, labBasePrice: 2, ratio: 1.5, maxLevel: 25, description: "+1 Pi√®ce par ennemi tu√©.", formula: FORMULAS.getKillBonus },
    { id: 'prison_cost', name: "Co√ªt Prison", tab: "Sorts", basePrice: 100, labBasePrice: 10, ratio: 1.5, maxLevel: 10, description: "R√©duit le co√ªt du sort Prison.", formula: SPELL_FORMULAS.getPrisonCost },
    { id: 'prison_duration', name: "Dur√©e Prison", tab: "Sorts", basePrice: 150, labBasePrice: 15, ratio: 1.5, maxLevel: 10, description: "Augmente la dur√©e d'immobilisation.", formula: SPELL_FORMULAS.getPrisonDuration },
    { id: 'rain_cost', name: "Co√ªt Pluie", tab: "Sorts", basePrice: 100, labBasePrice: 10, ratio: 1.5, maxLevel: 10, description: "R√©duit le co√ªt de la Pluie.", formula: SPELL_FORMULAS.getRainCost },
    { id: 'rain_damage', name: "D√©g√¢ts Pluie", tab: "Sorts", basePrice: 150, labBasePrice: 15, ratio: 1.5, maxLevel: 10, description: "Augmente les d√©g√¢ts de la Pluie.", formula: SPELL_FORMULAS.getRainDamage },
    { id: 'circle_cost', name: "Co√ªt Cercle", tab: "Sorts", basePrice: 100, labBasePrice: 10, ratio: 1.5, maxLevel: 10, description: "R√©duit le co√ªt du sort Cercle.", formula: SPELL_FORMULAS.getCircleCost },
    { id: 'circle_count', name: "Fl√®ches Plus", tab: "Sorts", basePrice: 150, labBasePrice: 15, ratio: 1.5, maxLevel: 10, description: "+2 Fl√®ches pour le Cercle.", formula: SPELL_FORMULAS.getCircleCount }
];

/* =========================================================
    FORMATIONS & SCHEMAS DE JOURS
   ========================================================= */

// Types de formations disponibles
const FORMATION_TYPES = {
    SINGLE: 'single',    // 1 ennemi
    CLUSTER: 'cluster',  // 3 ennemis tr√®s proches
    SQUARE: 'square',    // 4 ennemis en carr√©
    LINE: 'line',        // 5 ennemis en ligne
    HORDE: 'horde'       // 10 ennemis en grappe l√¢che
    // a ajouter sur une vague pour changer le d√©lai de spawn : "spawnInterval: 100"
};

// D√©finition pr√©cise des vagues pour chaque jour
const DAY_SCHEMAS = {
    // ==========================================
    // JOUR 1 : Tutoriel (Faible)
    // ==========================================
    1: [
        { wave: 1, enemies: [{type: 'normal', count: 5, hpMult: 1.0}] },
        { wave: 2, enemies: [{type: 'normal', count: 6, formation: 'cluster', hpMult: 1.1}] }, // Intro Cluster
        { wave: 3, enemies: [{type: 'sprinter', count: 4, formation: 'single', hpMult: 0.9}, {type: 'normal', count: 4, formation: 'single', hpMult: 1.1}] },
        { wave: 4, enemies: [{type: 'kamikaze', count: 4, formation: 'line', hpMult: 1.0}] }, // Intro Line + Kamikaze
        { wave: 5, enemies: [{type: 'tank', count: 2, formation: 'single', hpMult: 1.8}, {type: 'normal', count: 5, formation: 'single', hpMult: 1.2}] },
        { wave: 6, enemies: [{type: 'sprinter', count: 8, formation: 'line', hpMult: 1.0}] },
        { wave: 7, enemies: [{type: 'normal', count: 10, formation: 'single', hpMult: 1.3}] },
        { wave: 8, enemies: [{type: 'normal', count: 8, formation: 'horde', hpMult: 1.2}] }, // Intro Horde
        { wave: 9, enemies: [{type: 'tank', count: 3, formation: 'line', hpMult: 1.5}] },
        { wave: 10, enemies: [{type: 'boss', count: 1, formation: 'single', hpMult: 5}] }
    ],

    // ==========================================
    // JOUR 2 : Vitesse (Sprinters)
    // ==========================================
    2: [
        { wave: 1, enemies: [{type: 'normal', count: 6, formation: 'single', hpMult: 1.3}] },
        { wave: 2, enemies: [{type: 'sprinter', count: 8, formation: 'square', hpMult: 1.2}] }, // Carr√© de sprinters
        { wave: 3, enemies: [{type: 'kamikaze', count: 5, formation: 'single', hpMult: 1.2}, {type: 'normal', count: 5, formation: 'single', hpMult: 1.3}] },
        { wave: 4, enemies: [{type: 'normal', count: 10, formation: 'cluster', hpMult: 1.4}] },
        { wave: 5, enemies: [{type: 'tank', count: 2, formation: 'single', hpMult: 2.2}, {type: 'sprinter', count: 8, formation: 'single', hpMult: 1.1}] },
        { wave: 6, enemies: [{type: 'kamikaze', count: 6, formation: 'line', hpMult: 1.1}] },
        { wave: 7, enemies: [{type: 'sprinter', count: 12, formation: 'single', hpMult: 1.2}] },
        { wave: 8, enemies: [{type: 'sprinter', count: 10, formation: 'horde', hpMult: 1.3}] }, // Horde rapide
        { wave: 9, enemies: [{type: 'tank', count: 4, formation: 'square', hpMult: 2.0}] }, // Carr√© de tanks
        { wave: 10, enemies: [{type: 'boss', count: 1, formation: 'single', hpMult: 10}] }
    ],

    // ==========================================
    // JOUR 3 : Puissance (Tanks)
    // ==========================================
    3: [
        { wave: 1, enemies: [{type: 'normal', count: 8, formation: 'single', hpMult: 1.5}] },
        { wave: 2, enemies: [{type: 'tank', count: 4, formation: 'line', hpMult: 2.0}] }, // Ligne de tanks
        { wave: 3, enemies: [{type: 'normal', count: 5, formation: 'single', hpMult: 1.6}, {type: 'tank', count: 2, formation: 'single', hpMult: 2.2}] },
        { wave: 4, enemies: [{type: 'kamikaze', count: 8, formation: 'square', hpMult: 1.3}] },
        { wave: 5, enemies: [{type: 'tank', count: 3, formation: 'single', hpMult: 2.5}, {type: 'normal', count: 10, formation: 'single', hpMult: 1.6}] },
        { wave: 6, enemies: [{type: 'sprinter', count: 10, formation: 'line', hpMult: 1.4}] },
        { wave: 7, enemies: [{type: 'tank', count: 5, formation: 'single', hpMult: 2.1}] },
        { wave: 8, enemies: [{type: 'tank', count: 6, formation: 'cluster', hpMult: 2.3}] }, // Grappe de tanks
        { wave: 9, enemies: [{type: 'normal', count: 15, formation: 'horde', hpMult: 1.8}] },
        { wave: 10, enemies: [{type: 'boss', count: 1, formation: 'single', hpMult: 15}] }
    ],

    // ==========================================
    // JOUR 4 : Kamikazes (Explosions)
    // ==========================================
    4: [
        { wave: 1, enemies: [{type: 'normal', count: 10, formation: 'single', hpMult: 1.8}] },
        { wave: 2, enemies: [{type: 'kamikaze', count: 8, formation: 'horde', hpMult: 1.2}] }, // Horde de bombs
        { wave: 3, enemies: [{type: 'kamikaze', count: 5, formation: 'single', hpMult: 1.3}, {type: 'sprinter', count: 5, formation: 'single', hpMult: 1.5}] },
        { wave: 4, enemies: [{type: 'tank', count: 4, formation: 'square', hpMult: 2.5}] },
        { wave: 5, enemies: [{type: 'normal', count: 12, formation: 'single', hpMult: 2.0}] },
        { wave: 6, enemies: [{type: 'kamikaze', count: 10, formation: 'line', hpMult: 1.4}] }, // Ligne mortelle
        { wave: 7, enemies: [{type: 'tank', count: 3, formation: 'single', hpMult: 2.6}, {type: 'kamikaze', count: 6, formation: 'single', hpMult: 1.3}] },
        { wave: 8, enemies: [{type: 'normal', count: 15, formation: 'cluster', hpMult: 2.0}] },
        { wave: 9, enemies: [{type: 'kamikaze', count: 10, formation: 'square', hpMult: 1.5}] },
        { wave: 10, enemies: [{type: 'boss', count: 1, formation: 'single', hpMult: 22}] }
    ],

    // ==========================================
    // JOUR 5 : Le Chaos (Mixte intense)
    // ==========================================
    5: [
        { wave: 1, enemies: [{type: 'normal', count: 12, formation: 'single', hpMult: 2.2}] },
        { wave: 2, enemies: [{type: 'sprinter', count: 6, formation: 'square', hpMult: 1.6}, {type: 'tank', count: 2, formation: 'square', hpMult: 2.8}] }, // Double formation
        { wave: 3, enemies: [{type: 'kamikaze', count: 6, formation: 'single', hpMult: 1.5}, {type: 'normal', count: 8, formation: 'single', hpMult: 2.2}] },
        { wave: 4, enemies: [{type: 'tank', count: 5, formation: 'line', hpMult: 2.8}] },
        { wave: 5, enemies: [{type: 'sprinter', count: 15, formation: 'single', hpMult: 1.6}] },
        { wave: 6, enemies: [{type: 'kamikaze', count: 12, formation: 'horde', hpMult: 1.5}] },
        { wave: 7, enemies: [{type: 'tank', count: 6, formation: 'single', hpMult: 2.8}, {type: 'sprinter', count: 8, formation: 'single', hpMult: 1.7}] },
        { wave: 8, enemies: [{type: 'normal', count: 20, formation: 'line', hpMult: 2.4}] }, // Ligne g√©ante
        { wave: 9, enemies: [{type: 'tank', count: 4, formation: 'square', hpMult: 3.0}, {type: 'kamikaze', count: 4, formation: 'square', hpMult: 1.6}] },
        { wave: 10, enemies: [{type: 'boss', count: 1, formation: 'single', hpMult: 30}] }
    ],

    // ==========================================
    // JOUR 6 : Vitesse Pure
    // ==========================================
    6: [
        { wave: 1, enemies: [{type: 'sprinter', count: 15, formation: 'single', hpMult: 1.8}] },
        { wave: 2, enemies: [{type: 'sprinter', count: 12, formation: 'cluster', hpMult: 1.9}] },
        { wave: 3, enemies: [{type: 'kamikaze', count: 8, formation: 'single', hpMult: 1.6}, {type: 'tank', count: 4, formation: 'single', hpMult: 3.0}] },
        { wave: 4, enemies: [{type: 'sprinter', count: 10, formation: 'line', hpMult: 2.0}] }, // Mur de sprinters
        { wave: 5, enemies: [{type: 'normal', count: 15, formation: 'single', hpMult: 2.6}] },
        { wave: 6, enemies: [{type: 'sprinter', count: 15, formation: 'horde', hpMult: 1.8}] },
        { wave: 7, enemies: [{type: 'kamikaze', count: 10, formation: 'single', hpMult: 1.7}, {type: 'sprinter', count: 10, formation: 'single', hpMult: 1.9}] },
        { wave: 8, enemies: [{type: 'tank', count: 6, formation: 'cluster', hpMult: 3.2}] },
        { wave: 9, enemies: [{type: 'sprinter', count: 20, formation: 'line', hpMult: 2.0}] },
        { wave: 10, enemies: [{type: 'boss', count: 1, formation: 'single', hpMult: 40}] }
    ],

    // ==========================================
    // JOUR 7 : Mur de Chair (Nombreux)
    // ==========================================
    7: [
        { wave: 1, enemies: [{type: 'normal', count: 20, formation: 'single', hpMult: 2.8}] },
        { wave: 2, enemies: [{type: 'normal', count: 15, formation: 'horde', hpMult: 2.6}] }, // Horde massive
        { wave: 3, enemies: [{type: 'tank', count: 5, formation: 'single', hpMult: 3.2}, {type: 'normal', count: 15, formation: 'single', hpMult: 2.8}] },
        { wave: 4, enemies: [{type: 'kamikaze', count: 15, formation: 'square', hpMult: 1.8}] },
        { wave: 5, enemies: [{type: 'sprinter', count: 15, formation: 'single', hpMult: 2.1}] },
        { wave: 6, enemies: [{type: 'tank', count: 8, formation: 'line', hpMult: 3.3}] }, // Ligne de tanks
        { wave: 7, enemies: [{type: 'normal', count: 25, formation: 'single', hpMult: 2.8}] },
        { wave: 8, enemies: [{type: 'normal', count: 20, formation: 'cluster', hpMult: 2.8}] },
        { wave: 9, enemies: [{type: 'kamikaze', count: 15, formation: 'line', hpMult: 1.8}] },
        { wave: 10, enemies: [{type: 'boss', count: 2, formation: 'single', hpMult: 40}] }
    ],

    // ==========================================
    // JOUR 8 : High Level (Tout est fort)
    // ==========================================
    8: [
        { wave: 1, enemies: [{type: 'normal', count: 15, formation: 'single', hpMult: 3.2}, {type: 'tank', count: 3, formation: 'single', hpMult: 3.5}] },
        { wave: 2, enemies: [{type: 'tank', count: 8, formation: 'square', hpMult: 3.4}] }, // Carr√© de tanks (Dangereux)
        { wave: 3, enemies: [{type: 'sprinter', count: 15, formation: 'single', hpMult: 2.3}, {type: 'kamikaze', count: 10, formation: 'single', hpMult: 1.9}] },
        { wave: 4, enemies: [{type: 'normal', count: 25, formation: 'horde', hpMult: 3.0}] },
        { wave: 5, enemies: [{type: 'tank', count: 6, formation: 'single', hpMult: 3.5}, {type: 'sprinter', count: 10, formation: 'single', hpMult: 2.3}] },
        { wave: 6, enemies: [{type: 'kamikaze', count: 15, formation: 'cluster', hpMult: 2.0}] },
        { wave: 7, enemies: [{type: 'tank', count: 10, formation: 'line', hpMult: 3.5}] },
        { wave: 8, enemies: [{type: 'sprinter', count: 20, formation: 'horde', hpMult: 2.3}] },
        { wave: 9, enemies: [{type: 'normal', count: 10, formation: 'square', hpMult: 3.4}, {type: 'kamikaze', count: 6, formation: 'square', hpMult: 2.0}] },
        { wave: 10, enemies: [{type: 'boss', count: 2, formation: 'single', hpMult: 50}] }
    ],

    // ==========================================
    // JOUR 9 : L'Apocalypse (Avant infini)
    // ==========================================
    9: [
        { wave: 1, enemies: [{type: 'sprinter', count: 20, formation: 'single', hpMult: 2.5}, {type: 'normal', count: 15, formation: 'single', hpMult: 3.5}] },
        { wave: 2, enemies: [{type: 'tank', count: 10, formation: 'line', hpMult: 3.8}, {type: 'kamikaze', count: 10, formation: 'line', hpMult: 2.1}] }, // Double ligne
        { wave: 3, enemies: [{type: 'tank', count: 5, formation: 'single', hpMult: 3.8}, {type: 'sprinter', count: 10, formation: 'single', hpMult: 2.5}, {type: 'normal', count: 10, formation: 'single', hpMult: 3.5}] },
        { wave: 4, enemies: [{type: 'kamikaze', count: 20, formation: 'horde', hpMult: 2.2}] }, // Horde de bombes
        { wave: 5, enemies: [{type: 'normal', count: 30, formation: 'single', hpMult: 3.5}] },
        { wave: 6, enemies: [{type: 'tank', count: 8, formation: 'square', hpMult: 3.8}] }, // Carr√© de tanks costauds
        { wave: 7, enemies: [{type: 'sprinter', count: 25, formation: 'single', hpMult: 2.5}, {type: 'tank', count: 5, formation: 'single', hpMult: 3.8}] },
        { wave: 8, enemies: [{type: 'normal', count: 25, formation: 'cluster', hpMult: 3.6}] },
        { wave: 9, enemies: [{type: 'tank', count: 10, formation: 'line', hpMult: 4.0}, {type: 'kamikaze', count: 15, formation: 'line', hpMult: 2.2}] }, // Assaut final
        { wave: 10, enemies: [{type: 'boss', count: 2, formation: 'single', hpMult: 60}] } // Boss √©norme
    ]
};

// Vagues avec Variantes
const WAVE_SCHEMA = [
    { wave: 1, enemies: [{type: 'normal', count: 30, formation: 'single', spawnInterval: 300, hpMult: 4}] },
    { wave: 2, enemies: [{type: 'sprinter', formation: 'horde', count: 20, spawnInterval: 300, hpMult: 3}, {type: 'normal', count: 20, formation: 'single', spawnInterval: 300, hpMult: 4}] },
    { wave: 3, enemies: [{type: 'tank', count: 10, formation: 'single', spawnInterval: 400, hpMult: 4}, {type: 'normal', count: 8, formation: 'line', spawnInterval: 400, hpMult: 4}] },
    { wave: 4, enemies: [{type: 'kamikaze', count: 10, spawnInterval: 300, hpMult: 3}, {type: 'kamikaze', spawnInterval: 300, count: 10, hpMult: 3}] },
    { wave: 5, enemies: [{type: 'tank', formation: 'cluster', count: 8, hpMult: 4}, {type: 'boss', count: 1, hpMult: 70}] },
    { wave: 6, enemies: [{type: 'normal', count: 40, formation: 'single', spawnInterval: 300, hpMult: 5}, {type: 'kamikaze', formation: 'single', spawnInterval: 300, count: 15, hpMult: 3.2}] },
    { wave: 7, enemies: [{type: 'tank', count: 10, formation: 'horde', spawnInterval: 200, hpMult: 5}, {type: 'sprinter', formation: 'horde', spawnInterval: 200, count: 10, hpMult: 3.5}] },
    { wave: 8, enemies: [{type: 'sprinter', count: 40, formation: 'single', spawnInterval: 200, hpMult: 1.6}, {type: 'normal', count: 5, formation: 'single', spawnInterval: 200, hpMult: 5}] },
    { wave: 9, enemies: [{type: 'kamikaze', count: 20, formation: 'horde', spawnInterval: 100, hpMult: 3.5}, {type: 'tank', count: 10, formation: 'line', spawnInterval: 100, hpMult: 6}, {type: 'normal', formation: 'single', spawnInterval: 100, count: 50, hpMult: 5}] },
    { wave: 10, enemies: [{type: 'boss', count: 2, hpMult: 70}] }
];

/* =========================================================
   2. GESTION DES DONN√âES
   ========================================================= */

let playerData = {
    diamonds: 0,
    upgrades: {},
    settings: { music: 50, sfx: 80 },
    stats: {
        totalRuns: 0,
        totalKills: 0,
        totalBossKills: 0,
        totalDiamondsEarned: 0,
        bestRun: { day: 0, wave: 0, diamonds: 0, date: '' }
    }
};

// Initialisation basique des upgrades
UPGRADES_DATA.forEach(u => {
    if (playerData.upgrades[u.id] === undefined) playerData.upgrades[u.id] = 1;
});

let game = {
    state: 'MENU',
    day: 1,
    wave: 1,
    coins: 0,
    hp: 100,
    maxHp: 100,
    lastTime: 0,
    mineTimer: 0,
    speedMultiplier: 1,
    
    tempLevels: {}, 
    
    enemies: [],
    projectiles: [],
    particles: [],
    floatingTexts: [],
    bloodSplats: [],
    droppedDiamonds: [],
    
    spells: {
        prison: { lastCast: 0 },
        rain: { lastCast: 0 },
        circle: { lastCast: 0 }
    },
    targetingSpell: null,
    fallingArrows: [],
    
    waveActive: false,
    waveQueue: [],
    waveTotalEnemies: 0,
    waveKilledEnemies: 0,
    spawnTimer: 0,
    
    runDiamonds: 0,
    selectedEnemy: null,
    mouseX: 0,
    mouseY: 0
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

/* =========================================================
   GESTION AUDIO
   ========================================================= */

const sounds = {};

function playSound(id, volumeType = 'sfx') {
    // 1. V√©rifier si le son a bien √©t√© charg√© par loadAssets
    if (!sounds[id]) {
        console.error("ERREUR : Le son '" + id + "' n'est pas dans la liste des sons charg√©s.");
        return;
    }
    
    // 2. R√©cup√©rer le volume
    let vol = 1.0;
    if (volumeType === 'sfx') vol = playerData.settings.sfx / 100;
    if (volumeType === 'music') vol = playerData.settings.music / 100;

    if (vol <= 0) {
        return;
    }

    try {
        const snd = sounds[id];
        snd.volume = vol;
        if (id !== 'musique') {
             const clone = snd.cloneNode();
             clone.volume = vol;
             clone.play().catch(e => console.error("√âCHEC LECTURE DU FICHIER : " + id, e));
        } else {
             snd.currentTime = 0;
             snd.play().catch(e => console.error("√âCHEC LECTURE MUSIQUE : ", e));
        }

    } catch (e) {
        console.error("Erreur critique playSound:", id, e);
    }
}

/* =========================================================
   3. FONCTIONS UTILITAIRES & INIT
   ========================================================= */

const assets = {};
function loadAssets() {
    const loader = (key, src) => {
        const img = new Image();
        img.src = src;
        assets[key] = img;
    };
    loader('bg', CONFIG.images.bg);
    loader('bg_menu', CONFIG.images.bg_menu);
    loader('tower', CONFIG.images.tower);
    loader('mine', CONFIG.images.mine);
    loader('coin', CONFIG.images.coin);
    loader('diamond', CONFIG.images.diamond);
    loader('arrow', CONFIG.images.arrow);
    loader('blood', CONFIG.images.blood);
    loader('barreau', CONFIG.images.barreau);
    loader('prison_icon', CONFIG.images.prison_icon);
    loader('rain_icon', CONFIG.images.rain_icon);
    loader('circle_icon', CONFIG.images.cercle_icon);
    
    CONFIG.images.zombies.forEach((src, i) => loader(`zombie${i+1}`, src));
    CONFIG.images.bosses.forEach((src, i) => loader(`boss${i+1}`, src));
        // --- CHARGEMENT DES SONS ---
    const sndLoader = (key, src) => {
        const aud = new Audio();
        aud.src = src;
        sounds[key] = aud;
    };

    sndLoader('amelioration', './son/amelioration.mp3');
    sndLoader('erreur', './son/erreur.mp3');
    sndLoader('fermeture', './son/fermeture.mp3');
    sndLoader('fleche', './son/fleche.mp3');
    sndLoader('mort', './son/mort.mp3');
    sndLoader('mort2', './son/mort2.mp3');
    sndLoader('mort3', './son/mort3.mp3');
    sndLoader('mort4', './son/mort4.mp3');
    sndLoader('mort5', './son/mort5.mp3');
    sndLoader('mort6', './son/mort6.mp3');
    sndLoader('mortboss', './son/mortboss.mp3');
    
    sndLoader('musique', './son/musique.mp3');
    sounds['musique'].loop = true; // La musique doit boucler
    sounds['musique'].volume = playerData.settings.music / 100;

    sndLoader('onglet', './son/onglet.mp3');
    sndLoader('pluiefleche', './son/pluiefleche.mp3');
    sndLoader('cerclefleche', './son/cerclefleche.mp3');
    sndLoader('prison', './son/prison.mp3');
    sndLoader('explosion', './son/explosion.mp3');
    sndLoader('transitionjour', './son/transitionjour.mp3');
    sndLoader('fin', './son/fin.mp3');
}

// --- GESTION DU VOLUME EN TEMPS R√âEL ---

const musicSlider = document.getElementById('vol-music');
const sfxSlider = document.getElementById('vol-sfx');

// 1. Quand on bouge la barre de Musique
musicSlider.addEventListener('input', (e) => {
    const volumeValue = e.target.value / 100; // Convertir 0-100 en 0.0-1.0
    
    // Appliquer le volume directement √† l'objet audio qui joue en boucle
    if(sounds['musique']) {
        sounds['musique'].volume = volumeValue;
    }
    
    // Sauvegarder la pr√©f√©rence (comme dans votre fonction saveData)
    playerData.settings.music = e.target.value;
    localStorage.setItem('zombieTD_save_v7', JSON.stringify(playerData));
});

// 2. Quand on bouge la barre d'Effets Sonores (SFX)
sfxSlider.addEventListener('input', (e) => {
    playerData.settings.sfx = e.target.value;
    localStorage.setItem('zombieTD_save_v7', JSON.stringify(playerData));
});

function loadData() {
    const saved = localStorage.getItem('zombieTD_save_v7');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            playerData = { ...playerData, ...parsed };
            UPGRADES_DATA.forEach(u => {
                if (playerData.upgrades[u.id] === undefined) {
                    playerData.upgrades[u.id] = 1;
                }
            });

            document.getElementById('vol-music').value = playerData.settings.music;
            document.getElementById('vol-sfx').value = playerData.settings.sfx;
        } catch(e) { console.error("Save corrompu"); }
    }
    updateMenuUI();
    generateLabUI();
}

function saveData() {
    playerData.settings.music = document.getElementById('vol-music').value;
    playerData.settings.sfx = document.getElementById('vol-sfx').value;
    localStorage.setItem('zombieTD_save_v7', JSON.stringify(playerData));
}

function getTotalLevel(id) {
    const labLvl = playerData.upgrades[id] || 1;
    const tempLvl = game.tempLevels[id] || 0;
    return labLvl + tempLvl;
}

function initGame() {
    game.runStats = {
        kills: 0,
        bosses: 0,
        startTime: Date.now()
    };
    game.day = 1;
    game.wave = 1;
    game.coins = 100;
    game.runDiamonds = 0;
    game.bloodSplats = [];
    game.targetingSpell = null;
    game.fallingArrows = [];
    game.spells.prison.lastCast = -99999;
    game.spells.rain.lastCast = -99999;
    game.speedMultiplier = 1;
    
    UPGRADES_DATA.forEach(u => game.tempLevels[u.id] = 0);
    
    game.enemies = [];
    game.projectiles = [];
    game.particles = [];
    game.floatingTexts = [];
    game.droppedDiamonds = [];
    
    applyUpgradeStats();
    game.hp = game.maxHp; 
    
    game.state = 'PLAYING';
    
    document.getElementById('game-container').style.backgroundImage = "url('./images/fond.png')";
    document.getElementById('menu-overlay').classList.add('hidden');
    document.getElementById('gameover-overlay').classList.add('hidden');
    document.getElementById('hud-bar').classList.remove('hidden');
    speedBtnGroup.classList.remove('hidden');
    document.getElementById('btn-settings').classList.remove('hidden');
    
    updateHUD();
    startWave();
    if(sounds['musique']) {
        sounds['musique'].currentTime = 0; // On remet la piste √† 0 secondes
        sounds['musique'].play();          // On lance la lecture
    }
    game.lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

// Gestion du clic pour s√©lectionner un ennemi
canvas.addEventListener('mousedown', (e) => {
    if (game.state !== 'PLAYING') {
        return;
    }

    const rect = canvas.getBoundingClientRect();
    // Calcul de la position
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clickX = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;
    
    let clickedEnemy = null;
    
    // V√©rifier si on touche un ennemi
    for (let enemy of game.enemies) {
        const dist = Math.hypot(clickX - enemy.x, clickY - enemy.y);
        
        if (dist < enemy.size / 2 + 10) {
            clickedEnemy = enemy;
            break;
        }
    }
    for (let i = game.droppedDiamonds.length - 1; i >= 0; i--) {
        const d = game.droppedDiamonds[i];
        // Rayon de clic de 20 pixels autour du diamant
        const dist = Math.hypot(clickX - d.x, clickY - d.y);
        if (dist < 20) {
            d.isAnimating = true; // D√©clenche l'animation
            playSound('amelioration'); // Petit son de succ√®s
            clickedEnemy = null; // On annule la s√©lection d'ennemi si on clique un diamant
            break; // Un seul diamant √† la fois
        }
    }
    
    game.selectedEnemy = clickedEnemy;
    updateInspectorUI();
});

/* =========================================================
   4. LOGIQUE DE JEU
   ========================================================= */

function applyUpgradeStats() {
    const hpLvl = getTotalLevel('hp');
    game.maxHp = FORMULAS.getMaxHp(hpLvl);
    if (game.hp > game.maxHp) game.hp = game.maxHp;
}

function startWave() {
    game.waveActive = true;
    game.waveQueue = generateWave(game.day, game.wave);
    game.spawnTimer = 0;
    game.waveKilledEnemies = 0;
    game.waveTotalEnemies = game.waveQueue.length;
    const daySchemas = DAY_SCHEMAS[game.day];
    let customInterval = null;
    
    if (daySchemas) {
        const currentWaveSchema = daySchemas.find(w => w.wave === game.wave);
        if (currentWaveSchema && currentWaveSchema.spawnInterval) {
            customInterval = currentWaveSchema.spawnInterval;
        }
    }
    
    // On d√©finit l'intervalle pour cette vague (ou celui par d√©faut si rien n'est d√©fini)
    game.currentSpawnInterval = customInterval || CONFIG.spawnInterval;
    
    const bonus = FORMULAS.getWaveBonus(getTotalLevel('wave_bonus'));
    if (bonus > 0) {
        game.coins += bonus;
        createFloatingText(`+${bonus}`, canvas.width / 2, canvas.height / 2 - 50, '#f1c40f', {icon: 'coin'});
    }
    updateHUD();
}

function generateWave(day, waveNum) {
    let enemiesToQueue = [];
    
    // 1. On cherche si le jour a un sch√©ma personnalis√© dans DAY_SCHEMAS
    const customDay = DAY_SCHEMAS[day];
    
    if (customDay) {
        // Si le jour est d√©fini (ex: Jour 1), on suit son plan exact
        const schema = customDay.find(w => w.wave === waveNum);
        if (schema) {
            enemiesToQueue = JSON.parse(JSON.stringify(schema.enemies));
        } else {
            console.warn("Sch√©ma de vague introuvable pour ce jour/vague");
        }
    } else {
        // ==========================================
        // JOURS 10+ : STRUCTURE FIXE + STATS PROC√âDURALES
        // ==========================================
        
        // 1. On r√©cup√®re le mod√®le de base dans WAVE_SCHEMA
        // (waveNum 1 correspond √† l'index 0, waveNum 2 √† l'index 1, etc.)
        const schemaIndex = (waveNum - 1) % WAVE_SCHEMA.length; 
        const baseWaveData = WAVE_SCHEMA[schemaIndex];

        // 2. On calcule le facteur de difficult√© pour ce jour pr√©cis
        // Exemple: Jour 10 = x1.0, Jour 11 = x1.2, Jour 12 = x1.4...
        // On commence le scaling √† partir du Jour 10.
        const difficultyScale = 1 + ((day - 10) * 0.2); 

        // 3. On copie les donn√©es pour ne pas modifier l'original
        let waveData = JSON.parse(JSON.stringify(baseWaveData));

        // 4. On applique le "boost proc√©dural" sur chaque groupe d'ennemis
        waveData.enemies.forEach(group => {
            // A. On augmente le nombre d'ennemis
            if (group.count) {
                group.count = Math.ceil(group.count * difficultyScale);
                // On garde un minimum de 1 ennemi
                if (group.count < 1) group.count = 1; 
            }

            // B. On augmente la r√©sistance (PV)
            if (group.hpMult) {
                group.hpMult = group.hpMult * difficultyScale;
            }
        });

        // 5. On envoie les donn√©es modifi√©es √† la file d'attente
        enemiesToQueue = waveData.enemies;
    }

    // 3. TRANSFORMATION EN FILE D'ATTENTE (QUEUE)
    let finalQueue = [];

    enemiesToQueue.forEach(group => {
        const count = group.count || 1;
        const formation = group.formation || 'single';
        
        // Calcul des offsets pour les formes g√©om√©triques (Carr√©, Ligne...)
        let offsets = [];
        const spread = 60; 

        if (formation === 'single') {
            offsets = [{x:0, y:0}];
        } else if (formation === 'cluster') {
            for(let i=0; i<3; i++) offsets.push({x: (Math.random()-0.5)*40, y: (Math.random()-0.5)*40});
        } else if (formation === 'square') {
            offsets = [
                {x: -spread, y: -spread}, {x: spread, y: -spread},
                {x: -spread, y: spread},  {x: spread, y: spread}
            ];
        } else if (formation === 'line') {
            for(let i=0; i<Math.min(count, 5); i++) {
                offsets.push({x: (i - 2) * spread, y: 0});
            }
        } else if (formation === 'horde') {
            for(let i=0; i<Math.min(count, 10); i++) {
                offsets.push({x: (Math.random()-0.5)*spread*3, y: (Math.random()-0.5)*spread*3});
            }
        }

        // Pr√©paration du point d'ancrage pour les GROUPES (pour que Carr√©/Ligne reste group√©)
        let groupSide, groupBaseX, groupBaseY;
        
        if (formation !== 'single') {
            // Pour les groupes, on choisit UN seul c√¥t√© pour tout le monde
            const side = Math.floor(Math.random() * 4);
            const spawnMargin = 50;
            
            if (side === 0) { groupBaseX = Math.random() * canvas.width; groupBaseY = -spawnMargin; }
            else if (side === 1) { groupBaseX = canvas.width + spawnMargin; groupBaseY = Math.random() * canvas.height; }
            else if (side === 2) { groupBaseX = Math.random() * canvas.width; groupBaseY = canvas.height + spawnMargin; }
            else { groupBaseX = -spawnMargin; groupBaseY = Math.random() * canvas.height; }
        }

        // On remplit la file d'attente
        for(let i=0; i<count; i++) {
            let finalX, finalY;
            
            if (formation === 'single') {
                // --- MODIFICATION ICI : RANDOM SIDE POUR CHAQUE ENNEMI ---
                // Pour le mode 'single', on ne veut pas de groupe, on veut du chaos al√©atoire
                const side = Math.floor(Math.random() * 4);
                const spawnMargin = 50;
                
                if (side === 0) { finalX = Math.random() * canvas.width; finalY = -spawnMargin; } // Haut
                else if (side === 1) { finalX = canvas.width + spawnMargin; finalY = Math.random() * canvas.height; } // Droite
                else if (side === 2) { finalX = Math.random() * canvas.width; finalY = canvas.height + spawnMargin; } // Bas
                else { finalX = -spawnMargin; finalY = Math.random() * canvas.height; } // Gauche
            } else {
                // Pour les groupes, on utilise les coordonn√©es du groupe calcul√©es plus haut
                const offset = offsets[i % offsets.length] || {x:0, y:0};
                finalX = groupBaseX + offset.x;
                finalY = groupBaseY + offset.y;
            }
            
            finalQueue.push({
                type: group.type,
                hpMult: group.hpMult,
                spawnX: finalX,
                spawnY: finalY
            });
        }
    });

    return finalQueue;
}

function update(dt) {
    if (game.state !== 'PLAYING') return;
    // Mise √† jour en continu de l'ennemi s√©lectionn√© (car ses PV changent)
    if (game.selectedEnemy) {
        updateInspectorUI();
    }

    const effectiveDt = dt * game.speedMultiplier;
    const now = Date.now();

    // Mine
    game.mineTimer += effectiveDt;
    const mineProd = FORMULAS.getMineProduction(getTotalLevel('mine_rate'));
    if (game.mineTimer >= CONFIG.mineBaseInterval) {
        game.mineTimer = 0;
        playerData.diamonds += mineProd;
        game.runDiamonds += mineProd;
        saveData();
        createFloatingText(`+${mineProd}`, canvas.width - 100, canvas.height - 150, '#3498db', {icon: 'diamond'});
        updateHUD();
    }

    // Regen
    const regen = FORMULAS.getRegen(getTotalLevel('regen'));
    if (regen > 0 && game.hp < game.maxHp) {
        game.hp += regen * (effectiveDt / 1000);
        if(game.hp > game.maxHp) game.hp = game.maxHp;
    }

    // Spawning
    if (game.waveQueue.length > 0) {
        game.spawnTimer += effectiveDt;
        if (game.spawnTimer >= game.currentSpawnInterval) {
            spawnEnemy(game.waveQueue.shift());
            game.spawnTimer = 0;
        }
    } else if (game.enemies.length === 0 && game.waveActive) {
        game.waveActive = false;
        game.wave++;
        setTimeout(() => {
            if (game.wave > 10) {
                game.wave = 1;
                game.day++;
                game.bloodSplats = [];
                createFloatingText(`JOUR ${game.day}`, canvas.width/2, canvas.height/2, '#fff', 40);
                playSound('transitionjour');
            }
            startWave();
        }, 2000 / game.speedMultiplier);
    }

    handleTowerShooting(effectiveDt);
    updateEntities(effectiveDt);
    updateSpells(effectiveDt);
    updateHUDProgress();
    updateDroppedDiamonds(effectiveDt);
}

/* =========================================================
   5. GESTION DES SORTS
   ========================================================= */

function updateSpells(dt) {
    for (let i = game.fallingArrows.length - 1; i >= 0; i--) {
        const p = game.fallingArrows[i];
        p.y += p.speed * (dt/1000);
        
        if (p.y >= p.targetY) {
            const hitRadius = 20; 
            
            game.enemies.forEach(e => {
                const dist = Math.hypot(p.x - e.x, p.y - e.y);
                if (dist < e.size/2 + hitRadius) {
                    e.hp -= p.damage / CONFIG.spells.rain.arrowCount; 
                    createParticles(e.x, e.y, '#fff');
                    if (e.hp <= 0) killEnemy(e);
                }
            });
            
            createParticles(p.x, p.y, '#aaa');
            game.fallingArrows.splice(i, 1);
        }
    }
}

function castPrison(targetEnemy) {
    const now = Date.now();
    const spell = CONFIG.spells.prison;
    
    const cost = SPELL_FORMULAS.getPrisonCost(getTotalLevel('prison_cost'));
    const duration = SPELL_FORMULAS.getPrisonDuration(getTotalLevel('prison_duration'));

    if (now - game.spells.prison.lastCast < spell.cooldown) return;
    if (playerData.diamonds < cost) {
        createFloatingText("Pas assez de diamants !", game.mouseX, game.mouseY, '#e74c3c');
        playSound('erreur');
        return;
    }
    
    playerData.diamonds -= cost;
    game.spells.prison.lastCast = now;
    saveData();
    updateHUD();
    
    targetEnemy.frozenUntil = now + duration;
    createFloatingText("PRISON !", targetEnemy.x, targetEnemy.y, '#e74c3c');
    playSound('prison');
    
    game.targetingSpell = null;
}

function castRain(x, y) {
    const now = Date.now();
    const spell = CONFIG.spells.rain;
    
    const cost = SPELL_FORMULAS.getRainCost(getTotalLevel('rain_cost'));
    const damage = SPELL_FORMULAS.getRainDamage(getTotalLevel('rain_damage'));

    if (now - game.spells.rain.lastCast < spell.cooldown) return;
    if (playerData.diamonds < cost) {
        createFloatingText("Pas assez de diamants !", x, y, '#e74c3c');
        playSound('erreur');
        return;
    }
    
    playerData.diamonds -= cost;
    game.spells.rain.lastCast = now;
    saveData();
    updateHUD();
    
    for(let i=0; i<spell.arrowCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * spell.radius;
        const targetX = x + Math.cos(angle) * r;
        const targetY = y + Math.sin(angle) * r;
        const startY = -100 - Math.random() * 500; 
        
        game.fallingArrows.push({
            x: targetX,
            y: startY,
            targetY: targetY,
            speed: 800 + Math.random() * 400, 
            damage: damage
        });
    }
    playSound('pluiefleche');
    
    game.targetingSpell = null;
}

function castCircleArrows() {
    const now = Date.now();
    const spell = CONFIG.spells.circle;
    
    const cost = SPELL_FORMULAS.getCircleCost(getTotalLevel('circle_cost'));
    const count = SPELL_FORMULAS.getCircleCount(getTotalLevel('circle_count'));
    const damage = FORMULAS.getDamage(getTotalLevel('damage'));

    if (now - game.spells.circle.lastCast < spell.cooldown) return;
    if (playerData.diamonds < cost) {
        createFloatingText("Pas assez de diamants !", game.mouseX, game.mouseY, '#e74c3c');
        playSound('erreur');
        return;
    }
    
    playerData.diamonds -= cost;
    game.spells.circle.lastCast = now;
    saveData();
    updateHUD();
    
    // Tir en cercle
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    for(let i=0; i<count; i++) {
        const angle = (Math.PI * 2 / count) * i; 
        const vx = Math.cos(angle) * 400; 
        const vy = Math.sin(angle) * 400; 
        
        game.projectiles.push({
            x: cx,
            y: cy,
            vx: vx,
            vy: vy,
            damage: damage,
            isCrit: false,
            color: '#9b59b6',
            life: 2000
        });
    }
    playSound('cerclefleche');
    
    game.targetingSpell = null;
}

/* =========================================================
   6. ENTIT√âS
   ========================================================= */

function spawnEnemy(data) {
    let x, y;
    
    if (data.spawnX !== undefined && data.spawnY !== undefined) {
        x = data.spawnX;
        y = data.spawnY;
    } else {
        // Ancien code (random side)
        const side = Math.floor(Math.random() * 4);
        if (side === 0) { x = Math.random() * canvas.width; y = -50; }
        else if (side === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
        else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
        else { x = -50; y = Math.random() * canvas.height; }
    }

    let maxHp = 30 * data.hpMult;
    let speed = 65; 
    let dmg = 10 + (data.hpMult * 5); 
    let size = CONFIG.zombieSize;
    let color = '#2ecc71';
    let reward = CONFIG.coinDropMin + Math.random() * (CONFIG.coinDropMax - CONFIG.coinDropMin);
    let variant = data.type;
    let imgIndex = 0;
    let typeStr = '';

    if (variant === 'sprinter') {
        speed = 115;
        maxHp *= 0.8;
        imgIndex = CONFIG.enemies.sprinter[Math.floor(Math.random() * CONFIG.enemies.sprinter.length)];
    } else if (variant === 'tank') {
        speed = 40;
        maxHp *= 2.0;
        imgIndex = CONFIG.enemies.tank;
    } else if (variant === 'kamikaze') {
        speed = 90;
        dmg *= 1.5;
        imgIndex = CONFIG.enemies.kamikaze;
    } else if (variant === 'boss') {
        maxHp = 100 * data.hpMult;
        speed = 30;
        dmg = 50;
        size = CONFIG.bossSize;
        color = '#e74c3c';
        reward = CONFIG.bossDiamondDropBase * 5;
    } else {
        imgIndex = CONFIG.enemies.normal[Math.floor(Math.random() * CONFIG.enemies.normal.length)];
    }

    if (variant === 'boss') {
        const bossNum = Math.min(Math.floor((game.day - 1) / 2) + 1, 4); 
        typeStr = `boss${bossNum}`;
    } else {
        typeStr = `zombie${imgIndex+1}`;
    }

    const metadataKey = typeStr;
    const framesToUse = ZOMBIE_METADATA[metadataKey]?.frames || 12;

    game.enemies.push({ 
        x, y, 
        type: typeStr, 
        variant: variant, 
        hp: maxHp, 
        maxHp, 
        speed, 
        dmg, 
        size, 
        baseColor: color, 
        reward: Math.floor(reward),
        frame: 0,
        animTimer: 0,
        totalFrames: framesToUse,
        frozenUntil: 0 
    });
}

let shootTimer = 0;

function handleTowerShooting(dt) {
    const range = FORMULAS.getRange(getTotalLevel('range'));
    const delay = FORMULAS.getAttackDelay(getTotalLevel('speed'));
    const damage = FORMULAS.getDamage(getTotalLevel('damage'));
    const critChance = FORMULAS.getCritChance(getTotalLevel('crit'));
    const doubleShotChance = FORMULAS.getMultiShotChance(getTotalLevel('multishot'));
    
    shootTimer += dt;
    
    if (shootTimer >= delay) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const targets = game.enemies
            .filter(e => Math.hypot(e.x - cx, e.y - cy) <= range)
            .sort((a,b) => Math.hypot(a.x - cx, a.y - cy) - Math.hypot(b.x - cx, b.y - cy));
            
        if (targets.length > 0) {
            shootTimer = 0;
            const spawnX = cx;
            const spawnY = cy - (CONFIG.towerDisplayWidth / 2) + 20;
            
            let target1 = targets[0];
            let isCrit1 = Math.random() * 100 < critChance;
            let dmg1 = isCrit1 ? damage * 2 : damage;
            game.projectiles.push({ x: spawnX, y: spawnY, target: target1, speed: 400, damage: dmg1, isCrit: isCrit1 });
            playSound('fleche');
            
            if (targets.length > 1 && Math.random() * 100 < doubleShotChance) {
                let target2 = targets[1];
                let isCrit2 = Math.random() * 100 < critChance;
                let dmg2 = isCrit2 ? damage * 2 : damage;
                game.projectiles.push({ x: spawnX, y: spawnY, target: target2, speed: 400, damage: dmg2, isCrit: isCrit2 });
            }
        }
    }
}

function updateEntities(dt) {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const now = Date.now();

    for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const p = game.projectiles[i];

        // CAS 1 : Fl√®che t√©l√©guid√©e (Tour) - Elle a une cible (p.target)
        if (p.target) {
            // Si la cible est morte, on supprime la fl√®che
            if (!game.enemies.includes(p.target)) { 
                game.projectiles.splice(i, 1); 
                continue; 
            }
            
            const dx = p.target.x - p.x;
            const dy = p.target.y - p.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist < 10) {
                // Impact sur la cible
                p.target.hp -= p.damage;
                createParticles(p.x, p.y, p.isCrit ? '#ff00ff' : '#fff');
                
                const ls = FORMULAS.getLifesteal(getTotalLevel('lifesteal'));
                if (ls > 0) {
                    game.hp += p.damage * (ls / 100);
                    if(game.hp > game.maxHp) game.hp = game.maxHp;
                }
                
                if (p.target.hp <= 0) killEnemy(p.target);
                game.projectiles.splice(i, 1);
            } else {
                // Mouvement vers la cible
                p.x += (dx/dist) * p.speed * (dt/1000);
                p.y += (dy/dist) * p.speed * (dt/1000);
            }
        } 
        // CAS 2 : Fl√®che directionnelle (Sort Cercle) - Elle a une v√©locit√© (p.vx, p.vy)
        else {
            // Mouvement rectiligne
            p.x += p.vx * (dt/1000);
            p.y += p.vy * (dt/1000);
            
            // Dur√©e de vie (pour ne pas qu'elles volent √† l'infini)
            p.life -= dt;
            if (p.life <= 0 || p.x < -100 || p.x > canvas.width + 100 || p.y < -100 || p.y > canvas.height + 100) {
                game.projectiles.splice(i, 1);
                continue;
            }

            // V√©rification de collision avec TOUS les ennemis
            let hit = false;
            for (let e of game.enemies) {
                const dist = Math.hypot(p.x - e.x, p.y - e.y);
                // Hitbox un peu plus large (taille ennemi / 2 + marge)
                if (dist < e.size / 2 + 10) {
                    e.hp -= p.damage;
                    createParticles(e.x, e.y, '#9b59b6'); // Particules violettes
                    if (e.hp <= 0) killEnemy(e);
                    hit = true;
                    break; // Une fl√®che ne touche qu'un seul ennemi
                }
            }

            if (hit) {
                game.projectiles.splice(i, 1);
            }
        }
    }

    for (let i = game.enemies.length - 1; i >= 0; i--) {
        const e = game.enemies[i];
        
        const isFrozen = now < e.frozenUntil;

        if (!isFrozen) {
            const meta = ZOMBIE_METADATA[e.type] || { frames: 1, animDelay: 10 };
            e.animTimer += dt;
            if (e.animTimer > meta.animDelay * 8) { 
                e.animTimer = 0;
                e.frame = (e.frame + 1) % e.totalFrames;
            }
        }

        const dx = cx - e.x;
        const dy = cy - e.y;
        const dist = Math.hypot(dx, dy);
        
        const hitbox = CONFIG.towerDisplayWidth / 2; 
        
        if (dist < hitbox) {
            if (e.variant === 'kamikaze') {
                game.hp -= e.dmg;
                createParticles(e.x, e.y, '#e67e22'); // effet visuel
                killEnemy(e);
                continue;
            } else if (!isFrozen) {
                // Les autres ennemis ne font des d√©g√¢ts que s'ils ne sont pas gel√©s
                game.hp -= e.dmg * (dt / 1000);
                if (game.hp <= 0) gameOver();
            }
        } else {
            if (!isFrozen) {
                e.x += (dx/dist) * e.speed * (dt/1000);
                e.y += (dy/dist) * e.speed * (dt/1000);
            }
        }
    }
        
    updateParticles(dt);
    updateFloatingTexts(dt);
}

function updateInspectorUI() {
    const inspector = document.getElementById('enemy-inspector');
    
    // Si un ennemi est s√©lectionn√© et qu'il est encore en vie
    if (game.selectedEnemy && game.enemies.includes(game.selectedEnemy)) {
        const e = game.selectedEnemy;
        inspector.classList.remove('hidden'); // Afficher le panneau
        // R√©cup√©ration du nom sp√©cifique ou du type par d√©faut
        const displayName = ZOMBIE_NAMES[e.type] || e.type;
        const displayType = getZombieTypeName(e.variant);
        
        // Remplir les donn√©es
        document.getElementById('insp-name').innerText = displayName;
        document.getElementById('insp-hp').innerText = Math.ceil(e.hp) + ' / ' + Math.ceil(e.maxHp);
        document.getElementById('insp-dmg').innerText = e.dmg;
        document.getElementById('insp-type').innerText = displayType;
    } else {
        inspector.classList.add('hidden'); // Masquer le panneau
        game.selectedEnemy = null; // R√©initialiser
    }
}

function killEnemy(enemy) {
    if (enemy.variant === 'boss') {
        // Si c'est un boss, on joue le son sp√©cial
        playSound('mortboss');
    } else if (enemy.variant === 'kamikaze') {
        playSound('explosion');
    } else {
        // Si c'est un zombie normal, on choisit un son au hasard dans la liste
        const deathSounds = ['mort', 'mort2', 'mort3', 'mort4', 'mort5', 'mort6'];
        const randomSound = deathSounds[Math.floor(Math.random() * deathSounds.length)];
        playSound(randomSound);
    }
    const idx = game.enemies.indexOf(enemy);
    if (idx > -1) {
        game.enemies.splice(idx, 1);
        // Tracker statistiques
        game.runStats.kills++;
        if (enemy.variant === 'boss') {
            game.runStats.bosses++;
        }
        game.waveKilledEnemies++;
        
        game.bloodSplats.push({x: enemy.x, y: enemy.y});
        // --- DROP DIAMANT ---
        if (Math.random() < 0.1) {
            const diamondValue = game.day * 10;
            
            game.droppedDiamonds.push({
                x: enemy.x,
                y: enemy.y,
                value: diamondValue,
                spawnTime: Date.now(),
                duration: 5000, // 5 secondes
                isAnimating: false,
                targetX: 0,
                targetY: 0
            });
        }
        
        const killBonus = FORMULAS.getKillBonus(getTotalLevel('kill_bonus'));
        game.coins += enemy.reward + killBonus;
        
        createFloatingText(`+${enemy.reward + killBonus}`, enemy.x, enemy.y, '#f1c40f', {icon: 'coin'});
        
        if (enemy.variant === 'boss') {
            const bonus = CONFIG.bossDiamondDropBase + FORMULAS.getBossDiamondBonus(getTotalLevel('boss_diamond'));
            playerData.diamonds += bonus;
            game.runDiamonds += bonus;
            createFloatingText(`+${bonus}`, enemy.x, enemy.y - 20, '#3498db');
            saveData();
        }
        updateHUD();
    }
}

function createParticles(x, y, color) {
    for(let i=0; i<5; i++) {
        game.particles.push({ x, y, vx: (Math.random()-0.5)*100, vy: (Math.random()-0.5)*100, life: 500, color });
    }
}
function updateParticles(dt) {
    for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx * (dt/1000);
        p.y += p.vy * (dt/1000);
        p.life -= dt;
        if (p.life <= 0) game.particles.splice(i, 1);
    }
}
function createFloatingText(text, x, y, color, size=16, options={}) {
    game.floatingTexts.push({ text, x, y, color, life: 1000, maxLife: 1000, size, icon: options.icon });
}
function updateFloatingTexts(dt) {
    for (let i = game.floatingTexts.length - 1; i >= 0; i--) {
        const t = game.floatingTexts[i];
        t.y -= 20 * (dt/1000);
        t.life -= dt;
        if (t.life <= 0) game.floatingTexts.splice(i, 1);
    }
}

function updateDroppedDiamonds(dt) {
    const hudElement = document.getElementById('hud-diamonds');
    const canvasRect = canvas.getBoundingClientRect();
    
    // On r√©cup√®re la position pr√©cise de l'√©l√©ment HTML par rapport au Canvas
    // C'est n√©cessaire pour que l'animation atpile exactement sur le compteur
    const hudRect = hudElement.getBoundingClientRect();
    const scaleX = canvas.width / canvasRect.width;
    const scaleY = canvas.height / canvasRect.height;
    
    const targetHudX = (hudRect.left - canvasRect.left + hudRect.width/2) * scaleX;
    const targetHudY = (hudRect.top - canvasRect.top + hudRect.height/2) * scaleY;

    for (let i = game.droppedDiamonds.length - 1; i >= 0; i--) {
        const d = game.droppedDiamonds[i];

        // CAS 1 : Le joueur a cliqu√©, on anime vers le HUD
        if (d.isAnimating) {
            // Calcul de la direction
            const dx = targetHudX - d.x;
            const dy = targetHudY - d.y;
            
            // D√©placement fluide (Lerp) : on se rapproche de 15% de la distance restante √† chaque frame
            d.x += dx * 0.15;
            d.y += dy * 0.15;

            // Si on est assez proche du HUD, on consid√®re le diamant r√©cup√©r√©
            if (Math.hypot(dx, dy) < 10) {
                playerData.diamonds += d.value;
                game.runDiamonds += d.value;
                createFloatingText(`+${d.value}`, targetHudX, targetHudY, '#3498db', 20);
                saveData();
                updateHUD();
                game.droppedDiamonds.splice(i, 1); // On retire le diamant
            }
        } 
        // CAS 2 : Le diamant attend par terre
        else {
            // V√©rification du timer (5 secondes)
            if (Date.now() - d.spawnTime > d.duration) {
                game.droppedDiamonds.splice(i, 1); // Temps √©coul√©, on supprime
            }
        }
    }
}

function drawDroppedDiamonds() {
    const now = Date.now();
    
    game.droppedDiamonds.forEach(d => {
        
        ctx.drawImage(assets.diamond, d.x - 12, d.y - 12, 24, 24); // 24x24 pixels

        // Petit effet visuel : cercle qui r√©tr√©cit pour indiquer le temps restant
        if (!d.isAnimating) {
            const timeLeftPct = 1 - (now - d.spawnTime) / d.duration;
            ctx.strokeStyle = `rgba(52, 152, 219, ${timeLeftPct})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(d.x, d.y, 18, 0, Math.PI * 2 * timeLeftPct);
            ctx.stroke();
        }
    });
}

/* =========================================================
   7. RENDU
   ========================================================= */

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (game.state === 'PLAYING') {
        let bgToDraw = assets.bg;
        
        if (bgToDraw && bgToDraw.complete) {
            ctx.drawImage(bgToDraw, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#222'; 
            ctx.fillRect(0,0,canvas.width, canvas.height); 
        }
    }
    
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    if (assets.blood && assets.blood.complete) {
        game.bloodSplats.forEach(s => {
            ctx.drawImage(assets.blood, s.x - (23*CONFIG.bloodScale)/2, s.y - (17*CONFIG.bloodScale)/2, 23*CONFIG.bloodScale, 17*CONFIG.bloodScale);
        });
    }

    const mineX = cx + 250; 
    const mineY = cy - 150;
    if (assets.mine && assets.mine.complete) ctx.drawImage(assets.mine, mineX - CONFIG.mineSize/2, mineY - CONFIG.mineSize/2, CONFIG.mineSize, CONFIG.mineSize);
    else { ctx.fillStyle='#3498db'; ctx.fillRect(mineX-CONFIG.mineSize/2, mineY-CONFIG.mineSize/2, CONFIG.mineSize, CONFIG.mineSize); }
    
    // Info Mine
    ctx.fillStyle='#3498db'; 
    ctx.font='bold 12px Arial'; 
    ctx.textAlign='center';
    const mineProd = FORMULAS.getMineProduction(getTotalLevel('mine_rate'));
    ctx.fillText(`${mineProd} diam/10s`, mineX, mineY - CONFIG.mineSize/2 - 10);

    const barW = CONFIG.mineSize;
    const barH = 6;
    const barY = mineY + CONFIG.mineSize/2 + 8;
    ctx.fillStyle = '#333';
    ctx.fillRect(mineX - barW/2, barY, barW, barH);
    ctx.fillStyle = '#3498db';
    const barPct = game.mineTimer / CONFIG.mineBaseInterval;
    ctx.fillRect(mineX - barW/2, barY, barW * barPct, barH);

    const towerW = CONFIG.towerDisplayWidth;
    const towerH = towerW;
    
    if (assets.tower && assets.tower.complete) ctx.drawImage(assets.tower, cx - towerW/2, cy - towerH/2, towerW, towerH);
    else { ctx.fillStyle='#555'; ctx.fillRect(cx - towerW/2, cy - towerH/2, towerW, towerH); }
    
    ctx.fillStyle='red'; ctx.fillRect(cx-30, cy - towerH/2 - 10, 60, 8);
    ctx.fillStyle='#2ecc71'; ctx.fillRect(cx-30, cy - towerH/2 - 10, 60 * (game.hp/game.maxHp), 8);
    
    const range = FORMULAS.getRange(getTotalLevel('range'));
    if (Math.hypot(game.mouseX - cx, game.mouseY - cy) < towerW/2) {
        ctx.beginPath(); ctx.arc(cx, cy, range, 0, Math.PI*2);
        ctx.fillStyle='rgba(255,255,255,0.1)'; ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.floor(game.hp)} / ${Math.floor(game.maxHp)} PV`, cx, cy - towerH/2 - 20);
    }

    // Projectiles Tour
    if (assets.arrow && assets.arrow.complete) {
        const arrowW = CONFIG.arrowDisplayWidth;
        const arrowH = (arrowW / 164) * 934;
        
        game.projectiles.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);
            let angle = 0;
            if (p.target) {
                 // Angle vers la cible (Tour)
                angle = Math.atan2(p.target.y - p.y, p.target.x - p.x);
            } else {
                 // Angle selon le mouvement (Cercle)
                angle = Math.atan2(p.vy, p.vx);
            }
            ctx.rotate(angle + Math.PI / 2);
            ctx.drawImage(assets.arrow, -arrowW/2, -arrowH/2, arrowW, arrowH);
            ctx.restore();
        });
    } else {
        game.projectiles.forEach(p => {
            ctx.fillStyle = p.isCrit ? '#ff00ff' : 'yellow';
            ctx.beginPath(); ctx.arc(p.x, p.y, p.isCrit?6:4, 0, Math.PI*2); ctx.fill();
        });
    }

    // Fl√®ches Pluie
    if (assets.arrow && assets.arrow.complete) {
        const arrowW = CONFIG.arrowDisplayWidth;
        const arrowH = (arrowW / 164) * 934;
        game.fallingArrows.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(Math.PI);
            ctx.drawImage(assets.arrow, -arrowW/2, -arrowH/2, arrowW, arrowH);
            ctx.restore();
        });
    }

    const now = Date.now();
    game.enemies.forEach(e => {
        const sprite = assets[e.type];
        if (sprite && sprite.complete) {
            const frameW = sprite.width / e.totalFrames;
            
            ctx.save();
            ctx.translate(e.x, e.y);

            const dx = (canvas.width / 2) - e.x;
            
            // LOGIQUE D'ORIENTATION CORRIG√âE
            // Par d√©faut on suppose que le sprite regarde √† Droite (donc on flip s'il va √† gauche).
            // Si on va vers la droite (dx < 0), pas de flip.
            // Si on va vers la gauche (dx > 0), flip (-1).
            
            let shouldFlip = (dx > 0.5); // Logique standard pour zombie1 (regarde √† droite)
            
            // Si le sprite fait partie de la liste invers√©e (regarde √† Gauche nativement)
            if (INVERTED_SPRITES.some(s => e.type.includes(s))) {
                shouldFlip = !shouldFlip; // On inverse la logique
            }

            if (shouldFlip) ctx.scale(-1, 1);

            if (now < e.frozenUntil) {
                ctx.filter = 'grayscale(100%) brightness(50%)';
            }

            ctx.drawImage(sprite, 
                e.frame * frameW, 0, frameW, sprite.height,
                -e.size/2, -e.size/2, e.size, e.size
            );
            ctx.restore();
        }
        
        ctx.fillStyle='red'; ctx.fillRect(e.x-15, e.y-e.size/2-10, 30, 4);
        ctx.fillStyle='#2ecc71'; ctx.fillRect(e.x-15, e.y-e.size/2-10, 30*(e.hp/e.maxHp), 4);

        if (now < e.frozenUntil && assets.barreau && assets.barreau.complete) {
            ctx.drawImage(assets.barreau, e.x - e.size/2, e.y - e.size/2, e.size, e.size);
        }
    });

    game.particles.forEach(p => {
        ctx.globalAlpha = p.life/500;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1;
    });

    game.floatingTexts.forEach(t => {
        let currentX = t.x;
        if (t.icon === 'coin' && assets.coin) {
            ctx.drawImage(assets.coin, t.x - 16, t.y - 10, 16, 16);
            currentX += 18;
        }
        else if (t.icon === 'diamond' && assets.diamond) {
        ctx.drawImage(assets.diamond, t.x - 16, t.y - 10, 16, 16);
        currentX += 18;
        }
        ctx.fillStyle = t.color;
        ctx.font = `bold ${t.size}px Arial`;
        ctx.globalAlpha = t.life/t.maxLife;
        ctx.fillText(t.text, currentX, t.y);
        ctx.globalAlpha = 1;
    });
    drawDroppedDiamonds();

    if (game.state === 'PLAYING') drawGameUI();
}

/* =========================================================
   8. UI DU JEU (UPGRADES + SORTS + VITESSE)
   ========================================================= */

let activeTab = "Bastion";
const tabs = ["Bastion", "PV", "√âconomie", "Sorts"];

function drawGameUI() {
    const bottomY = canvas.height - 120;
    
    drawUpgradeUI(bottomY);
    drawSpellUI(bottomY);
    
    drawSpeedButton();

    if (game.targetingSpell) {
        drawTargetingCursor();
    }
}

// Fonction globale pour changer la vitesse
function setSpeed(val) {
    game.speedMultiplier = val;
    
    // Mise √† jour l'√©tat "actif" sur les boutons
    for (let i = 1; i <= 3; i++) {
        const btn = document.getElementById(`btn-speed-${i}`);
        if (val === i) btn.classList.add('active');
        else btn.classList.remove('active');
    }
    
    // Forcer le redessin imm√©diat pour √©viter de sauter √† travers les autres √©l√©ments
    // (Optionnel mais recommand√© pour la fluidit√© visuelle)
    draw(); 
}

function drawSpeedButton() {
    // annuler
}

function drawUpgradeUI(bottomY) {
    const upgrades = UPGRADES_DATA.filter(u => u.tab === activeTab);

    ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0, bottomY, canvas.width, 120);
    
    const tabWidth = 100;
    tabs.forEach((t, i) => {
        const tx = 20 + i*(tabWidth+10);
        ctx.fillStyle=(t===activeTab)?'#555':'#333';
        ctx.fillRect(tx, bottomY-30, tabWidth, 30);
        ctx.strokeStyle='#777'; ctx.strokeRect(tx, bottomY-30, tabWidth, 30);
        ctx.fillStyle='#fff'; ctx.font='14px Arial'; ctx.textAlign='center';
        ctx.fillText(t, tx+tabWidth/2, bottomY-10);
    });
    
    const btnW = 160, btnH = 90, gap = 15;
    upgrades.forEach((u, i) => {
        const bx = 20 + i*(btnW+gap);
        const by = bottomY+10;
        
        const totalLvl = getTotalLevel(u.id);
        const tempLvl = game.tempLevels[u.id];
        const max = u.maxLevel;
        
        const price = Math.floor(u.basePrice * Math.pow(u.ratio, tempLvl));
        const afford = game.coins >= price;
        const isMax = totalLvl >= max;
        
        ctx.fillStyle=isMax?'#2c3e50':(afford?'#34495e':'#2c3e50');
        ctx.strokeStyle=afford&&!isMax?'#f1c40f':'#555'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.roundRect(bx, by, btnW, btnH, 5); ctx.fill(); ctx.stroke();
        
        ctx.textAlign='left'; ctx.fillStyle='#fff'; ctx.font='bold 13px Arial';
        ctx.fillText(`${u.name} (${totalLvl}/${max})`, bx+10, by+20);
        
        ctx.font='11px Arial'; ctx.fillStyle='#aaa';
        ctx.fillText(`Run: +${tempLvl}`, bx+10, by+35);
        
        let valTxt = u.formula(totalLvl);
        if(u.id === 'multishot') valTxt = valTxt.toFixed(1) + "%";
        else if(u.id === 'crit') valTxt += "%";
        else if(u.id === 'damage') valTxt = Math.floor(valTxt) + " d√©g√¢ts";
        else if(u.id === 'speed') valTxt = Math.floor(valTxt) + " ms";
        else if(u.id === 'hp') valTxt = Math.floor(valTxt) + " PV";
        else if(u.id === 'regen') valTxt = valTxt.toFixed(1) + " HP/s";
        else if(u.id === 'lifesteal') valTxt = valTxt.toFixed(1) + "%";
        else if(u.id === 'wave_bonus') valTxt += "$";
        else if(u.id === 'mine_rate') valTxt += " diam/10s";
        else if(u.id === 'boss_diamond') valTxt += " +diam";
        else if(u.id === 'kill_bonus') valTxt = `+${Math.floor(valTxt)} /kill`; 
        // Formules Sorts
        else if(u.id === 'prison_cost') valTxt = Math.floor(valTxt) + " üíé";
        else if(u.id === 'prison_duration') valTxt = (valTxt/1000).toFixed(1) + "s";
        else if(u.id === 'rain_cost') valTxt = Math.floor(valTxt) + " üíé";
        else if(u.id === 'rain_damage') valTxt = Math.floor(valTxt) + " d√©g√¢ts";
        else if(u.id === 'circle_cost') valTxt = Math.floor(valTxt) + " üíé"; 
        else if(u.id === 'circle_count') valTxt = valTxt + " fl√®ches"; 
        else valTxt += "px";
        
        ctx.fillText(valTxt, bx+10, by+50);
        
        if(!isMax) {
            ctx.fillStyle=afford?'#f1c40f':'#e74c3c'; 
            ctx.font='bold 14px Arial';
            
            const txtAcheter = "Acheter: ";
            const startX = bx + 10;
            const widthAcheter = ctx.measureText(txtAcheter).width;
            ctx.fillText(txtAcheter, startX, by+75);
            
            let textX = startX + widthAcheter;
            ctx.fillText(`${price}`, textX, by+75);
            
            const priceWidth = ctx.measureText(`${price}`).width;
            const iconSize = 14;
            
            if (assets.coin && assets.coin.complete) {
                ctx.drawImage(assets.coin, textX + priceWidth + 5, by+75-iconSize, iconSize, iconSize);
            }
            
        } else {
            ctx.fillStyle='#2ecc71'; ctx.fillText('MAX', bx+10, by+75);
        }
        u.clickArea = {x:bx, y:by, w:btnW, h:btnH};
    });
}

function drawSpellUI(bottomY) {
    const spellKeys = Object.keys(CONFIG.spells);
    const iconSize = 50;
    const margin = 10;
    // Ajustement de la position X pour centrer ou aligner √† droite selon le nombre de sorts
    const startX = canvas.width - (spellKeys.length * (iconSize + margin)) - 20;
    
    const spellY = bottomY - 90;
    
    const now = Date.now();
    const cursor = game.mouseX;
    const cursorY = game.mouseY;

    spellKeys.forEach((key, index) => {
        const spell = CONFIG.spells[key];
        const x = startX + index * (iconSize + margin);
        const y = spellY; 

        // --- CORRECTION ICI : Calcul dynamique du co√ªt pour TOUS les sorts ---
        let currentCost = spell.cost; // Valeur par d√©faut
        
        if (key === 'prison') {
            currentCost = SPELL_FORMULAS.getPrisonCost(getTotalLevel('prison_cost'));
        } else if (key === 'rain') {
            currentCost = SPELL_FORMULAS.getRainCost(getTotalLevel('rain_cost'));
        } else if (key === 'circle') {
            currentCost = SPELL_FORMULAS.getCircleCost(getTotalLevel('circle_cost'));
        }

        const isReady = (now - game.spells[key].lastCast) >= spell.cooldown;
        const canAfford = playerData.diamonds >= currentCost;
        const isActive = game.targetingSpell === key;

        // Fond du bouton
        ctx.fillStyle = isActive ? '#f1c40f' : '#444';
        if (!isReady) ctx.fillStyle = '#222';
        
        ctx.fillRect(x, y, iconSize, iconSize);
        ctx.strokeStyle = isActive ? '#fff' : '#777';
        ctx.lineWidth = isActive ? 3 : 1;
        ctx.strokeRect(x, y, iconSize, iconSize);

        // --- CORRECTION ICI : S√©lection de la bonne image ---
        let imgKey = '';
        if (key === 'prison') imgKey = 'prison_icon';
        else if (key === 'rain') imgKey = 'rain_icon';
        else if (key === 'circle') imgKey = 'circle_icon'; // Ajout du cercle

        if (assets[imgKey] && assets[imgKey].complete) {
            ctx.drawImage(assets[imgKey], x, y, iconSize, iconSize);
        } else {
            // Fallback si l'image n'est pas charg√©e
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(key.charAt(0).toUpperCase(), x + iconSize/2, y + iconSize/1.5);
        }

        // Overlay de rechargement (Cooldown)
        if (!isReady) {
            const elapsed = now - game.spells[key].lastCast;
            const pct = Math.min(1, elapsed / spell.cooldown);
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            // On dessine le rectangle de haut en bas pour l'effet cooldown
            ctx.fillRect(x, y, iconSize, iconSize * (1 - pct));
        }

        // Tooltip au survol
        if (cursor >= x && cursor <= x + iconSize && cursorY >= y && cursorY <= y + iconSize) {
            drawTooltip(spell, x, y, isReady, canAfford, currentCost);
        }
        
        // Zone de clic pour la souris
        spell.clickArea = { x, y, w: iconSize, h: iconSize };
    });
}

function drawTooltip(spell, x, y, isReady, canAfford, dynamicCost) {
    const w = 200;
    const h = 80;
    const tipX = x - (w - 50); 
    const tipY = y - h - 10;
    
    ctx.fillStyle = 'rgba(20, 20, 20, 0.95)';
    ctx.strokeStyle = '#f1c40f';
    ctx.lineWidth = 1;
    ctx.fillRect(tipX, tipY, w, h);
    ctx.strokeRect(tipX, tipY, w, h);
    
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(spell.name, tipX + 10, tipY + 20);
    
    ctx.font = '12px Arial';
    ctx.fillStyle = '#ccc';
    ctx.fillText(spell.desc, tipX + 10, tipY + 40);
    
    ctx.fillStyle = canAfford ? '#3498db' : '#e74c3c';
    ctx.fillText(`Co√ªt: ${Math.floor(dynamicCost)} üíé`, tipX + 10, tipY + 60);
    
    if (!isReady) {
        const remain = Math.ceil((spell.cooldown - (Date.now() - game.spells[spell.id].lastCast))/1000);
        ctx.fillStyle = '#aaa';
        ctx.fillText(`Recharge: ${remain}s`, tipX + 10, tipY + 75);
    }
}

function drawTargetingCursor() {
    if (game.targetingSpell === 'rain') {
        ctx.beginPath();
        ctx.arc(game.mouseX, game.mouseY, CONFIG.spells.rain.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(241, 196, 15, 0.2)';
        ctx.fill();
        ctx.strokeStyle = '#f1c40f';
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    } else if (game.targetingSpell === 'prison') {
        ctx.beginPath();
        ctx.arc(game.mouseX, game.mouseY, 30, 0, Math.PI * 2);
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 2;
        ctx.stroke();
    } else if (game.targetingSpell === 'circle') {
        // --- AJOUT POUR LE CERCLE DE FL√àCHES ---
        const text = "Tirer";
        ctx.font = 'bold 14px Arial';
        const textWidth = ctx.measureText(text).width;
        const padding = 8;
        const boxW = textWidth + padding * 2;
        const boxH = 24;
        const boxX = game.mouseX - boxW / 2;
        const boxY = game.mouseY + 25; // Positionn√© sous le curseur

        // Fond du texte pour qu'il soit lisible
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(boxX, boxY, boxW, boxH);
        
        // Bordure dor√©e
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 1;
        ctx.strokeRect(boxX, boxY, boxW, boxH);

        // Le texte lui-m√™me
        ctx.fillStyle = '#f1c40f';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, game.mouseX, boxY + boxH / 2);
    }
}

/* =========================================================
   9. RESOLUTION & ZOOM FIX
   ========================================================= */

function resizeCanvas() {
    const container = document.getElementById('game-container');
    canvas.width = 1280;
    canvas.height = 720;
}

window.addEventListener('load', resizeCanvas);
window.addEventListener('resize', resizeCanvas);

/* =========================================================
   10. EVENTS & LOOP
   ========================================================= */
function saveRunStats() {
    const now = new Date();
    const dateStr = now.toLocaleDateString() + ' ' + now.toLocaleTimeString();

    // 1. Mise √† jour des totaux globaux
    playerData.stats.totalRuns++;
    playerData.stats.totalKills += game.runStats.kills;
    playerData.stats.totalBossKills += game.runStats.bosses;
    playerData.stats.totalDiamondsEarned += game.runDiamonds;

    // 2. V√©rification Meilleure Run
    const current = { day: game.day, wave: game.wave, diamonds: game.runDiamonds, date: dateStr };
    const best = playerData.stats.bestRun;

    let isNewBest = false;
    if (current.day > best.day) {
        isNewBest = true;
    } else if (current.day === best.day) {
        if (current.wave > best.wave) {
            isNewBest = true;
        } else if (current.wave === best.wave) {
            if (current.diamonds > best.diamonds) {
                isNewBest = true;
            }
        }
    }

    if (isNewBest) {
        playerData.stats.bestRun = current;
    }

    saveData(); // Sauvegarde dans localStorage
}

function gameOver() {
    if(sounds['musique']) sounds['musique'].pause();
    playSound('fin');
    saveRunStats(); 

    game.state = 'GAMEOVER';
    document.getElementById('gameover-overlay').classList.remove('hidden');
    document.getElementById('hud-bar').classList.add('hidden');
    speedBtnGroup.classList.add('hidden');
    document.getElementById('btn-settings').classList.add('hidden');
    document.getElementById('go-day').innerText = game.day;
    document.getElementById('go-wave').innerText = game.wave;
    document.getElementById('go-diamonds').innerText = game.runDiamonds;
    if(sounds['musique']) {
        sounds['musique'].pause();
    }
}

function gameLoop(timestamp) {
    const dt = timestamp - game.lastTime;
    game.lastTime = timestamp;
    update(dt);
    draw();
    if (['PLAYING', 'MENU'].includes(game.state)) requestAnimationFrame(gameLoop);
}

canvas.addEventListener('mousedown', (e) => {
    if (game.state !== 'PLAYING') return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    const bottomY = canvas.height - 120;

    // GESTION (Boutons x1, x2, x3) ---
    if (game.speedBtnArea && x >= game.speedBtnArea.x && x <= game.speedBtnArea.x + game.speedBtnArea.w &&
        y >= game.speedBtnArea.y && y <= game.speedBtnArea.y + game.speedBtnArea.h) {
        
        // On v√©rifie sur quel bouton on a cliqu√© via l'ID (btn-speed-1, btn-speed-2, btn-speed-3)
        if (e.target.id.includes('btn-speed-')) {
            const speed = parseInt(e.target.id.replace('btn-speed-', ''));
            if(speed !== game.speedMultiplier) {
                setSpeed(speed);
                // return; // On sort de la fonction pour ne pas traiter le clic comme clic sur le canvas
            } else {
                playSound('amelioration');
            }
            // NOTE : Si on clique sur btn-settings, ce code ne sera pas ex√©cut√© √† cause du `return` plus bas. Le code existant de gestion du bouton settings se trouve dans la partie "EVENTS" plus bas.
            // Si vous souhaitez que x3 r√©initialise √† x1, d√©commentez la ligne `game.speedMultiplier = 1;` ici.
            return; 
        } else {
            playSound('amelioration'); // Son g√©n√©rique de clic pour les boutons de vitesse
        }
    }

    let clickedSpell = false;
    Object.values(CONFIG.spells).forEach(spell => {
        if (spell.clickArea && x >= spell.clickArea.x && x <= spell.clickArea.x + spell.clickArea.w &&
            y >= spell.clickArea.y && y <= spell.clickArea.y + spell.clickArea.h) {
            
            if (game.targetingSpell === spell.id) {
                game.targetingSpell = null;
            } else {
                game.targetingSpell = spell.id;
            }
            clickedSpell = true;
        }
    });

    if (clickedSpell) return;

    if (game.targetingSpell) {
        if (e.button === 0) { 
            if (game.targetingSpell === 'prison') {
                const target = game.enemies.find(en => Math.hypot(en.x - x, en.y - y) < en.size);
                if (target) {
                    castPrison(target);
                } else {
                    createFloatingText("Cible invalide", x, y, '#e74c3c');
                }
            } else if (game.targetingSpell === 'rain') {
                castRain(x, y);
            }
            else if (game.targetingSpell === 'circle') {
                castCircleArrows();
                game.targetingSpell = null;
                return;
            }
        } else if (e.button === 2) { 
            game.targetingSpell = null;
        }
        return;
    }

    if (y > bottomY-30 && y < bottomY) {
        tabs.forEach((t, i) => {
            // Zone de clic de l'onglet
            if (x > 20+i*(110) && x < 20+i*(110)+100) {
                activeTab = t;
                playSound('onglet'); // Joue le son
                // Force le redessin imm√©diat pour r√©activit√© visuelle
                draw(); 
            }
        });
        return; // Important : on arr√™te ici pour ne pas cliquer "√† travers" l'onglet
    }
    
    UPGRADES_DATA.filter(u => u.tab === activeTab).forEach(u => {
        if(u.clickArea && x>u.clickArea.x && x<u.clickArea.x+u.clickArea.w && y>u.clickArea.y && y<u.clickArea.y+u.clickArea.h) {
            buyUpgrade(u);
        }
    });
});

canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (game.state === 'PLAYING') {
        game.targetingSpell = null;
    }
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    game.mouseX = (e.clientX - rect.left) * scaleX;
    game.mouseY = (e.clientY - rect.top) * scaleY;
});

function buyUpgrade(upgrade) {
    const totalLvl = getTotalLevel(upgrade.id);
    if(totalLvl >= upgrade.maxLevel) return;
    
    const price = Math.floor(upgrade.basePrice * Math.pow(upgrade.ratio, game.tempLevels[upgrade.id]));
    
    if(game.coins >= price) {
        // SUCC√àS
        game.coins -= price;
        game.tempLevels[upgrade.id]++;
        
        playSound('amelioration'); // Joue le son de succ√®s
        createFloatingText("Upgrade!", canvas.width/2, canvas.height/2+100, '#fff');
        
        applyUpgradeStats();
        updateHUD();
    } else {
        // √âCHEC (Optionnel : jouer le son d'erreur)
        createFloatingText("Pas assez !", canvas.width/2, canvas.height/2+100, 'red');
        playSound('erreur'); 
    }
}

/* =========================================================
   11. GESTION UI DOM (Menu / Labo)
   ========================================================= */

let activeTabLab = "Bastion";

function updateHUD() {
    document.getElementById('hud-coins').innerText = game.coins;
    document.getElementById('hud-diamonds').innerText = playerData.diamonds;
    document.getElementById('hud-day').innerText = game.day;
    document.getElementById('hud-wave').innerText = game.wave;
}
function updateHUDProgress() {
    if (game.waveTotalEnemies > 0) {
        const pct = (game.waveKilledEnemies / game.waveTotalEnemies) * 100;
        document.getElementById('wave-progress').style.width = `${pct}%`;
    } else document.getElementById('wave-progress').style.width = '0%';
}

function updateMenuUI() {
    document.getElementById('menu-diamonds').innerText = playerData.diamonds;
}

function generateLabUI() {
    const container = document.getElementById('lab-content');
    container.innerHTML = '';
    
    const upgrades = UPGRADES_DATA.filter(u => u.tab === activeTabLab);
    
    upgrades.forEach(u => {
        const lvl = playerData.upgrades[u.id] || 1;
        const max = u.maxLevel;
        const price = Math.floor(u.labBasePrice * Math.pow(u.ratio, (lvl-1)));
        
        const card = document.createElement('div');
        card.className = 'lab-card';
        
        card.innerHTML = `
            <div>
                <h3>${u.name}</h3>
                <p>Niveau Permanent: <b>${lvl}/${max}</b></p>
                <p style="font-size:0.8rem; color:#888;">${u.description}</p>
            </div>
            <div style="margin-top:10px;">
                ${lvl < max 
                  ? `<button onclick="labBuy('${u.id}')" style="cursor:pointer; width:100%; padding:8px; background:#3498db; color:white; border:none; border-radius:3px; font-weight:bold;">${price} üíé</button>` 
                  : `<button disabled style="width:100%; padding:8px; background:#27ae60; color:white; border:none; border-radius:3px;">MAX</button>`}
            </div>
        `;
        container.appendChild(card);
    });
    
    document.getElementById('lab-diamonds').innerText = playerData.diamonds;
}

window.labBuy = function(id) {
    const u = UPGRADES_DATA.find(x => x.id === id);
    let currentLvl = playerData.upgrades[id] || 1;
    
    if(currentLvl >= u.maxLevel) return;
    
    const price = Math.floor(u.labBasePrice * Math.pow(u.ratio, (currentLvl-1)));
    
    if(playerData.diamonds >= price) {
        // SUCC√àS
        playerData.diamonds -= price;
        playerData.upgrades[id] = currentLvl + 1;
        
        playSound('amelioration'); // Joue le son ici
        
        saveData();
        generateLabUI();
        updateMenuUI();
    } else {
        // √âCHEC
        playSound('erreur');
    }
}

document.querySelectorAll('.lab-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        playSound('onglet');
        document.querySelectorAll('.lab-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        activeTabLab = tab.dataset.tab;
        generateLabUI();
    });
});

function openSettings(context) {
    const btnResume = document.getElementById('btn-resume');
    const btnCloseMenu = document.getElementById('btn-close-settings-menu');
    const btnQuit = document.getElementById('btn-quit');
    const creditsSection = document.getElementById('credits-section');
    
    if (context === 'MENU') {
        btnResume.classList.add('hidden');
        btnCloseMenu.classList.remove('hidden');
        btnQuit.classList.add('hidden');
    } else if (context === 'GAME') {
        btnResume.classList.remove('hidden');
        btnCloseMenu.classList.add('hidden');
        btnQuit.classList.remove('hidden');
    }
    
    creditsSection.classList.add('hidden');
    document.getElementById('settings-overlay').classList.remove('hidden');
}

// fonction utilitaire

function getSpellTooltipText(spellId) {
    if (spellId === 'prison') {
        const cost = SPELL_FORMULAS.getPrisonCost(getTotalLevel('prison_cost'));
        const duration = (SPELL_FORMULAS.getPrisonDuration(getTotalLevel('prison_duration')) / 1000).toFixed(1);
        return `Co√ªt: ${cost} üíé<br>CD: 30s<br>Dur√©e: ${duration}s`;
    } 
    else if (spellId === 'rain') {
        const cost = SPELL_FORMULAS.getRainCost(getTotalLevel('rain_cost'));
        const dmg = SPELL_FORMULAS.getRainDamage(getTotalLevel('rain_damage'));
        return `Co√ªt: ${cost} üíé<br>CD: 20s<br>D√©g√¢ts: ${dmg}`;
    }
    else if (spellId === 'circle') {
        const cost = SPELL_FORMULAS.getCircleCost(getTotalLevel('circle_cost'));
        const count = SPELL_FORMULAS.getCircleCount(getTotalLevel('circle_count'));
        return `Co√ªt: ${cost} üíé<br>CD: 10s<br>Fl√®ches: ${count}`;
    }
    return "";
}

/* --- GESTION DES STATISTIQUES --- */

function openStats() {
    const s = playerData.stats;
    
    // Remplir les champs
    document.getElementById('stat-total-runs').innerText = s.totalRuns;
    document.getElementById('stat-total-kills').innerText = s.totalKills;
    document.getElementById('stat-total-bosses').innerText = s.totalBossKills;
    document.getElementById('stat-total-diamonds').innerText = s.totalDiamondsEarned;
    
    // Meilleure run
    document.getElementById('stat-best-date').innerText = s.bestRun.date || '-';
    document.getElementById('stat-best-day').innerText = s.bestRun.day;
    document.getElementById('stat-best-wave').innerText = s.bestRun.wave;
    document.getElementById('stat-best-diamonds').innerText = s.bestRun.diamonds;

    // Calcul temps approximatif (si vous voulez le faire, sinon juste statique pour l'instant)
    // Ici on met 0 min par d√©faut car le temps de jeu total n'est pas sauvegard√© sp√©cifiquement dans cette version simple.
    document.getElementById('stat-playtime').innerText = "Donn√©es non disponibles"; 

    // Afficher l'overlay
    document.getElementById('menu-overlay').classList.add('hidden');
    document.getElementById('stats-overlay').classList.remove('hidden');
    playSound('amelioration');
}

function closeStats() {
    document.getElementById('stats-overlay').classList.add('hidden');
    document.getElementById('menu-overlay').classList.remove('hidden');
    playSound('fermeture');
}

// DOM Events
document.getElementById('btn-play').addEventListener('click', () => {
    playSound('amelioration'); // Ajoute le son ici
    initGame(); // Lance la partie
});
document.getElementById('btn-lab').addEventListener('click', () => {
    document.getElementById('menu-overlay').classList.add('hidden');
    document.getElementById('lab-overlay').classList.remove('hidden');
    generateLabUI();
    playSound('amelioration');
});
document.getElementById('btn-close-lab').addEventListener('click', () => {
    playSound('fermeture');
    document.getElementById('lab-overlay').classList.add('hidden');
    document.getElementById('menu-overlay').classList.remove('hidden');
});
document.getElementById('btn-menu').addEventListener('click', () => {
    if(sounds['musique']) sounds['musique'].pause();
    playSound('fermeture');
    document.getElementById('gameover-overlay').classList.add('hidden');
    document.getElementById('menu-overlay').classList.remove('hidden');
    document.getElementById('game-container').style.backgroundImage = '';
    updateMenuUI();
});

document.getElementById('btn-menu-settings').addEventListener('click', () => {
    openSettings('MENU');
    playSound('amelioration');
});

document.getElementById('btn-settings').addEventListener('click', () => {
    playSound('amelioration');
    if (game.state === 'PLAYING') {
        game.state = 'PAUSED';
        openSettings('GAME');
    }
});

document.getElementById('btn-resume').addEventListener('click', () => {
    document.getElementById('settings-overlay').classList.add('hidden');
    playSound('amelioration');
    if (game.state === 'PAUSED') {
        game.state = 'PLAYING';
        game.lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
});
document.getElementById('btn-quit').addEventListener('click', () => {
    playSound('fermeture');
    saveRunStats();
    if(sounds['musique']) {
        sounds['musique'].pause();
    }
    document.getElementById('settings-overlay').classList.add('hidden');
    document.getElementById('hud-bar').classList.add('hidden');
    speedBtnGroup.classList.add('hidden');
    document.getElementById('btn-settings').classList.add('hidden');
    game.state = 'MENU';
    document.getElementById('menu-overlay').classList.remove('hidden');
    document.getElementById('game-container').style.backgroundImage = '';
    updateMenuUI();
});

document.getElementById('btn-close-settings-menu').addEventListener('click', () => {
    playSound('fermeture');
    document.getElementById('settings-overlay').classList.add('hidden');
});

document.getElementById('btn-reset-save').addEventListener('click', () => {
    playSound('fermeture');
    if(confirm("√ätes-vous s√ªr de vouloir tout r√©initialiser ?")) {
        localStorage.removeItem('zombieTD_save_v7');
        location.reload();
        playSound('amelioration');
    }
});

document.getElementById('btn-toggle-credits').addEventListener('click', () => {
    document.getElementById('credits-section').classList.toggle('hidden');
    playSound('amelioration');
});
// Ouverture Statistiques
document.getElementById('btn-stats').addEventListener('click', openStats);
// Fermeture Statistiques
document.getElementById('btn-close-stats').addEventListener('click', closeStats);
loadAssets();
loadData();
resizeCanvas();

/* =========================================================
   12. GESTION DES RACCOURCIS CLAVIER
   ========================================================= */

window.addEventListener('keydown', (e) => {
    // On v√©rifie que le jeu est bien en cours pour ne pas interf√©rer avec les menus
    if (game.state !== 'PLAYING') return;

    // --- 1. S√âLECTION DES SORTS (Pav√© Num√©rique) ---
    // On utilise e.code pour d√©tecter la touche physique du pav√© num√©rique
    
    // Touche 1 (Prison)
    if (e.code === 'Numpad1') {
        if (game.targetingSpell === 'prison') {
            game.targetingSpell = null; // D√©s√©lectionner si d√©j√† actif
        } else {
            game.targetingSpell = 'prison'; // S√©lectionner
        }
    }
    // Touche 2 (Pluie de Fl√®ches)
    else if (e.code === 'Numpad2') {
        if (game.targetingSpell === 'rain') {
            game.targetingSpell = null;
        } else {
            game.targetingSpell = 'rain';
        }
    }
    // Touche 3 (Cercle de Fl√®ches)
    else if (e.code === 'Numpad3') {
        if (game.targetingSpell === 'circle') {
            game.targetingSpell = null;
        } else {
            game.targetingSpell = 'circle';
        }
    }

    // --- 2. CONTR√îLE DE LA VITESSE (+ et - du Pav√© Num√©rique) ---
    
    // Touche + (Augmenter vitesse)
    else if (e.code === 'NumpadAdd') { 
        // On v√©rifie qu'on ne d√©passe pas 3
        if (game.speedMultiplier < 3) {
            // On appelle ta fonction existante setSpeed qui g√®re l'interface (boutons actifs)
            setSpeed(game.speedMultiplier + 1);
            e.preventDefault(); // Emp√™che le scroll ou autre comportement par d√©faut
        }
    }
    // Touche - (Diminuer vitesse)
    else if (e.code === 'NumpadSubtract') { 
        // On v√©rifie qu'on ne descend pas sous 1
        if (game.speedMultiplier > 1) {
            setSpeed(game.speedMultiplier - 1);
            e.preventDefault();
        }
    }
});

</script>
<div id="footerText">¬©Sluto - Ce jeu fait partie du<a href="../../index.html"> Projet ToncPlay</a>.</div>
</body>
</html>